<!--# *i-bem.js*: Руководство пользователя-->

**FIXME** codestyle не ставить пробел после if, открывающейся круглой
  скобки, только после фигурных

**FIXME** сделать хайлайтинг примеров.

# Общие сведения #

## *i-bem.js*: Javascript-фреймворк для БЭМ ##

*i-bem.js* — специализированный JavaScript-фреймворк для веб-разработки
в рамках [БЭМ-методологии](http://ru.bem.info/method/).  С помощью
*i-bem.js* можно:

 * разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
 * описывать логику работы блока в декларативном стиле — как набор состояний;
 * легко интегрировать JavaScript-код с CSS в стиле БЭМ и BEMHTML-шаблонами;
 * гибко переопределять поведение библиотечных блоков.

*i-bem.js* не предназначен:

 * для замены фреймворка общего назначения, подобного jQuery.

## БЭМ-методология и JavaScript ##

С точки зрения БЭМ-методологии веб-интерфейс строится из независимых
**блоков** (внутри которых могут быть выделены **элементы**). И блоки,
и элементы могут иметь состояния, описываемые **модификаторами**.

Работа веб-интерфейса обеспечивается несколькими **технологиями**
(HTML, CSS, JS...), и описание блока складывается из реализаций в этих
технологиях. Обычно реализация разбита на несколько файлов, например:

 * `my-block.css` — описывает внешний вид блока;
 * `my-block.bemhtml` — шаблоны для генерации HTML-представления блока;
 * `my-block.js` — описывает **динамическое поведение** блока в браузере.

Фреймворк *i-bem.js* позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:

 + **Блок** — JS-компонент, описывающий логику работы однотипных
 элементов интерфейса. Например, все кнопки могут быть реализованы в
 виде блока `button`. Тогда, в соответствии с БЭМ-методологией,
 `button.css` определяет внешний вид всех кнопок, а `button.js` —
 логику их работы.
 + На каждой странице может размещаться более одного **экземпляра**
 блока (например, кнопки). Каждому экземпляру блока соответствует
 JS-объект, динамически создаваемый в памяти браузера и хранящий
 состояние данного экземпляра. JS-объект хранит ссылку на DOM-узел,
 к которому привязан данный экземпляр блока.
 + **Элементы** — DOM-узлы, вложенные в DOM-узел блока и имеющие атрибут
   `class`, указывающий на их роль в БЭМ-предметной области (имя блока
   и элемента). Элементы блока доступны через [JS-API](#elem-api)
   экземпляра блока.
 + **Модификаторы** — Хранят информацию о состоянии блока и его
   элементов. Сотояние модификаторов записывается в атрибуте `class`
   на DOM-узлах блока и элементов. Управление модификаторами
   производится через [JS-API](#mods-api) экземпляра блока.



## Как использовать i-bem.js ##

Фреймворк *i-bem.js* входит в состав библиотеки [bem-core](http://github.com/bem/bem-core/).

Cущественные компоненты реализации:

* Модуль [`i-bem`](#i-bem).<br/>
  Базовая реализация JS-блока i-bem, от которой наследуются все блоки в
  *i-bem.js*. Блок i-bem написан с расчетом на использование в любом
  JS-окружении, как на клиенте, так и на сервере (например, в
  Node.js).
* Модуль [`i-bem__dom`](#i-bem__dom).<br/> Базовая
реализация блока, привязанного к DOM-узлу. Реализует специфическую для
браузеров функциональность по работе с DOM. Зависит от `jQuery`.
  
Зависимости: 

 * jQuery (для `i-bem__dom`). При использовании bem-core отдельная установка jQuery не требуется.
 * Модульная система
   [ymaps/modules][ymaps]. При
   использовании [bem-tools][] с технологией `.browser.js` эта зависимость
   удовлетворяется автоматически.

Можно использовать *i-bem.js* как часть полного стека
БЭМ-инструментов. В этом случае свой проект удобно создавать на основе
шаблонного репозитория
[project-stub](http://github.com/bem/project-stub/), в котором
настроена автоматическая установка зависимостей.

Если не планируется использование других технологий БЭМ-платформы, можно
подключить библиотеку bem-core в существующий проект любым доступным способом.
   

## Сборка ##

Разработка в рамках БЭМ-методологии ведется модульно: каждый блок
программируется отдельно, код блоков встраивается в финальный исходный
код веб-страниц с помощью процедур **сборки**.

В файловой системе блок удобно представлять в виде каталога, а реализацию блока 
в каждой из технологий — в виде отдельного файла:

    desktop.blocks/
        my-block/
            my-block.css
            my-block.js
            my-block.bemhtml
            ...

    desktop.blocks/
        other-block/
            other-block.css
            other-block.js
            other-block.bemhtml
            ...

Для каждой веб-страницы код использованных на ней блоков может быть собран в единые файлы: 

    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...

Для автоматизации сборки кода результирующих веб-страниц из отдельных
описаний блоков можно использовать любой из существующих инструментов:

* [bem-tools](http://github.com/bem/bem-tools/);
* [enb](https://github.com/enb-make/enb) совместно с [enb-modules](https://github.com/enb-make/enb-modules).


## Почему i-bem.js так называется ##

В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и 
гибко настраивать поведение библиотеки на разных уровнях переопределения.

Служебным блокам в БЭМ было принято давать имена с префиксом `i-`. Таким образом, имя `*i-bem.js*` 
читается как «реализация блока `i-bem` в технологии `js`».


# Привязка блоков к HTML #

JavaScript-компоненты в *i-bem.js* служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — привязать обработку определенных событий к
указанному HTML-фрагменту. 

 * Первичным является DOM-дерево документа, в котором размечены блоки,
   элементы и модификаторы (в атрибутах `class` HTML-элементов).
 * Таким образом, в DOM-дереве каждому экземпляру блока соответствует DOM-элемент.
 * Если блок имеет JavaScript-реализацию, к каждому упоминанию блока
   на странице (DOM-узлу) должен быть привязан JS-объект —
   экземпляр блока. Это делается за счет добавления [описания блока](#html-syntax) в
   атрибуты `class` и `onclick` DOM-узла.
 * JS-объект, привязанный к DOM-элементу, обрабатывает происходящие на
   нем [DOM-события](#dom-events) и хранит состояние данного экземпляра блока.
 * *i-bem.js* также дает возможность реализовать JS-компонент, не
   привязанный к DOM, — [блок без DOM-представления](#i-blocks),
   имеющий API, аналогичное обычным блокам. 

Описанный подход привязки JavaScript-компонент к HTML имеет следующие преимущества:

 * естественная деградация интерфейса на клиентах с отключенным JavaScript;
 * _прогрессивный рендеринг_ — возможность начать отрисовку элементов
   интерфейса до окончания загрузки всех данных страницы (например,
   изображений).

<a name="html-syntax"></a>

## Синтаксис привязки блоков ##

Чтобы привязать блок к HTML-элементу (например, `<div>...</div>`), необходимо: 

 1. **Отметить блок в DOM-дереве**.<br/>
 Включить имя блока в список классов HTML-элемента (атрибут `class`).

	`<div class="` __`my-block`__ `">...</div>`

 2. **Инициализировать экземпляр блока**.<br/> 
 Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.

	`<div class="my-block ` **`i-bem`** `">...</div>`

3. **Передать параметры экземпляру блока**.<br/> Поместить параметры
 блока в атрибут `onclick`. Параметры блока представляют собой JS-хэш
 структуры __имя блока—хэш параметров__.  Параметры передаются
 экземпляру блока в момент инициализации. Атрибут `onclick` выбран
 потому, что в нем можно разместить нативный JS-код
 ([подробнее...](#onclick)).

	`<div class="my-block i-bem" onclick="` **`return { my-block: { name: 'ya' }}`** `">...</div>`
	

Соотношение блоков и DOM-элементов не обязательно должно быть
одно-однозначным. Возможны следующие типы связи: 
 
### Один DOM-элемент — один JS-блок ###

Самый простой и распространенный способ привязки блоков к HTML.

Пример: HTML-элемент `div`, на котором размещен блок `my-block`, параметры блока — пустой список `{}`.

```HTML
<div class="my-block i-bem"
	 onclick="return { 
		 my-block: {},
	}">
	...
  </div>
```


<a name="mixes"></a>

### Один DOM-элемент — несколько JS-блоков ###

Техника размещения нескольких блоков на одном DOM-элементе в БЭМ-методологии называется **микс**. 

Пример: HTML-элемент `div`, на котором размещены блок `user` с
параметром `name`: `pushkin` и блок `avatar` с параметром `img`: `http://...`.

```HTML
 <div class="user avatar i-bem"
	 onclick="return { 
		 user: { name: 'pushkin' },
		 avatar: { img: 'http://...' }
	 }">
	 ...
  </div>
```

<a name="distrib-block"></a>

### Один JS-блок на нескольких DOM-элементах ###

Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из
нескольких компонент, сосотяние которых должно быть
согласовано. Например, виджет «вкладки», где клик по заголовку вкладки
(один HTML-элемент), меняет содержимое вкладки (другой
HTML-элемент). Другой пример — маркер, обозначающий точку на карте
(первый элемент) и связанное с ним описание точки в списке рядом с
картой (второй элемент).

Чтобы привязать экземпляр блока к нескольким DOM-элементам, нужно в параметрах
блока на всех связанных с ним DOM-узлах указать одинаковое значение `id`. В
качестве значения `id` может выступать произвольная строка.

Пример: Экземпляр блока `notebook` привязан к HTML-элементам `div` и `span`, в
параметрах блока указан общий `id` — `maintab`.

```HTML
<div class="notebook i-bem"
	onclick="return { 
		notebook: { id: 'maintab' },
	}">
</div>

...

<span class="notebook i-bem"
	onclick="return { 
		notebook: { id: 'maintab' },
	}">
</span>
```

В результате при инциализации блоков создается один JS-объект, поле
 [`{jQuery} domElem`](#i-bem__dom.domElem) которого содержит ссылки на оба DOM-узла.

Идентификатор `id` используется *только в момент инициализации*
экземпляра блока. Значение `id` должно быть уникальным в пределах
экземпляров одного блока в рамках одной
[волны инициализации](#init-wave).


<a name="i-blocks"></a>

### Блоки без DOM-представления ###

Инфраструктурный код, решающий общие задачи интерфейса: связь с бэкэндом, общие вычисления и т.п. — при работе с *i-bem.js* 
можно оформлять в виде блока, как и весь прочий JS-код. Чтобы не привязывать такие блоки к DOM-дереву икусственно, 
*i-bem.js* предоставляет возможность создавать блоки без DOM-представления. 

Блоки без DOM-представления:

 * В HTML-коде страницы не указываются.
 * Декларируются как [доопределение модуля `i-bem`](#bem-decl), а не
   `i-bem__dom`, как блоки с DOM-представлением.
 * Должны быть [инициализированы явно](#bem-create).
   


## Синтаксис передачи параметров ##

Параметры блока — произвольный JavaScript-объект, который будет передан блоку в момент инициализации. 
Параметры позволяют модифицировать поведение экземпляра блока, привязанного к данному DOM-узлу.

<a name="onclick"></a>

В значении атрибута `onclick` указываются параметры *всех JS-блоков, размещенных на данном узле*. 
Параметры передаются с помощью конструкции `return` в виде хэша:

 + ключ — `{String} `имя блока;
 + значение — `{Object}` параметры данного блока. Если данному экземпляру блока не требуются 
   параметры, указывается пустой хэш `{}`.

Такой формат параметров продиктован следующими соображениями:

 * Указание имени блока в параметрах позволяет избежать необходимости парсить значение атрибута `class`,
   что упрощает и ускоряет инициализацию блоков. Это же решение позволяет размещать несколько блоков на одном 
   DOM-узле без необходимости множить атрибуты элемента.
 * Передача параметров в виде нативного JS-объекта позволяет обходиться для этой цели одним HTML-атрибутом
   и передавать в качестве параметров произвольный JS-код.

-------------------------------------------------------------------------------

**NB** При необходимости можно переопределить имя атрибута для
передачи параметров блока. Например, в библиотеке
[bem-bl](https://github.com/bem/bem-bl) в блоках, предназначенных для
тач-интерфейсов, используется атрибут `ondblclick`.

-------------------------------------------------------------------------------


# Декларация блока #

JS-реализация блока описывает функциональность определенного класса элементов веб-интерфейса. В конкретных 
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует 
функциональность всего класса и имеет собственное состояние, независимое от остальных.

В терминах парадигмы объектно-ориентированного программирования: 

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в _методах_ класса (= блока). 
Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в *i-bem.js* принято называть **декларацией**, чтобы подчеркнуть принятый в БЭМ декларативный
стиль программирования. В соответствии с декларативным стилем поведение блока программируется как 
утверждения вида _набор условий — реакция блока_.

	
## Синтаксис декларации ##

Чтобы декларировать новый JS-блок **с DOM-представлением**
(привязанный к DOM-элементу), необходимо доопределить [ymaps][]-модуль `i-bem__dom`. 

Блоки декларируются с помощью метода `decl`, принимающим три
параметра:

1. Имя блока `{String}` или [описание блока](#decl-selector) `{Object}`.
2. Методы экземпляра блока — `{Object}`.
3. Статические методы — `{Object}`.

```JavaScript
modules.define('i-bem__dom', function(provide, DOM) {
	DOM.decl(/* имя или описание блока */,
		{ 
			/* методы экземпляра */
		},
		{
			/* статические методы */
		}
	);
provide(DOM);
});
```

-------------------------------------------------------------------------------

**NB** С точки зрения модульной системы [ymaps][], декларации разных
  блоков представляеют собой переопределение одного и того же модуля
  `i-bem__dom`. Однако с точки зрения *i-bem.js* таким образом создаются
  *разные объекты* для построения экземпляров блоков.

-------------------------------------------------------------------------------

<a name="bem-decl"></a>

Блоки, не имеющие DOM-представления, декларируются как доопределение [ymaps][]-модуля `i-bem`. 
Для декларации используется метод `decl`, принимающий те же параметры,
что и метод `decl` модуля `i-bem__dom`:

```JavaScript
modules.define('i-bem', function(provide, BEM) {
	BEM.decl(/* имя или описание блока \*/,
		{ 
			/* методы экземпляра \*/
		},
		{
			/* статические методы \*/
		}
	);
provide(BEM);
});
```


-------------------------------------------------------------------------------

**NB**: Оформлять инфраструктурный код в виде блока без
  DOM-представления удобно, если в нем планируется использовать API
  БЭМ-блоков (состояния, выражаемые модификаторами, BEM-события и
  т. п.). Если использовать БЭМ-предметную область не планируется,
  инфраструктурный код можно оформлять в виде [ymaps][]-модуля. Например:

```JavaScript
modules.define('router', function(provide) {
	provide({
		route : function() { ... }
	});
});
```

-------------------------------------------------------------------------------

<a name="decl-selector"></a>


## Описание блока в декларации ##

Первый параметр метода `decl` представляет собой описание блока, в
котором будут применяться объявленные в декларации методы.  Описание
обязательно содержит имя блока и может дополнительно содержать:

* ограничение сферы действия декларации определенной модификацией
  блока;
* список родительских блоков, методы которых должен наследовать данный
  блок. 

Описание может быть задано в одной из двух форм:

1. Имя блока — строка.<br/> 
   Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).
Пример: декларация методов для блока `button`.

```JavaScript
DOM.decl('button',
	{ /* методы экземпляра */ },
	{ /* статические методы */ }
);
```

2. Описание блока — хэш.<br/>  Например, так может выглядеть декларация
   методов для блока `button` с модификатором `type` в значении
   `link` (описывает поведение псевдокнопок):

```JavaScript
DOM.decl({ block: 'button', modName: 'type, modVal: 'link' }, 
	{ /* методы экземпляра */ }, 
	{ /* статические методы */ } 
);
```

Другой пример: блок `checkbutton` наследуется от блоков `button` и `checkbox`:

```JavaScript
DOM.decl({ block: 'checkbutton', baseBlock: 'button', baseMix: 'checkbox' }, 
	{ /* методы экземпляра */ }, 
	{ /* статические методы */ } 
);
```

Подробнее см. описание метода [i-bem.decl](#i-bem.decl).

## Контекст ##

**Методы экземпляра блока** исполняются в контексте JS-объекта
экземпляра блока. Соответственно, ключевое слово `this` в методах
экземпляра блока ссылается на JS-объект **экземпляра блока**.

**Статические методы** исполняются в контексте JS-объекта,
  соответствующего классу блока. Соответственно, ключевое слово `this`
  в статических методах блока ссылается на **класс блока**, а не на
  экземпляр.

Контекст содержит зарезервированные поля:

 + `this.__self`: Ссылается на статические методы класса, к которому
   принадлжит экземпляр. Определен в методах экземпляра блока. Для
   статических методов не имеет смысла и не определен.

	Пример: Вызов статического метода `staticMethod` в методе
    `onEvent` экземпляра блока `my-block`.

```JavaScript
DOM.decl('my-block', {
	onEvent: function() {
		this.__self.staticMethod(); // вызов статического метода
		this.doMore();
	}, 
	{
	staticMethod: function() { ... }; // определение статического метода
	}
});
```

 + `this.__base`: Ссылается на реализацию метода в базовом классе, от которого наследуется данный.
    Позволяет выполнить super call. Определен в методах экземпляра
    блока и в статических методах блока.

	Пример: вызов (и модификация) метода `onClick` родительского класса (базовой реализации метода в классе `button`).

```JavaScript
 DOM.decl({ block: 'my-button', baseBlock: 'button' }, {
	 onClick: function() {
		 this.__base();
		 this.doMore();
	 }, 
	 {}
 });
```

-------------------------------------------------------------------------------

**NB**: Для обращения к DOM-элементу блока используется поле
  экземпляра блока [`domElem`](#i-bem__dom.domElem).

-------------------------------------------------------------------------------


# События #
	
В *i-bem.js* поддерживается два вида событий:

<a name="dom-events"></a>

* **DOM-события** — JavaScript-события, возникающие на DOM-узлах,
  соответствующих блокам. Это события, отражающие взаимодействие
  пользователя с интерфейсом (клик, наведение мыши, ввод текста и
  т.п.). DOM-события обычно обрабатывает тот экземпляр блока, на
  DOM-узле которого они возникли.
* **BEM-события** — собственные события, которые генерируются
  блоками. Позволяют организовать API для
  [взаимодействия с блоком](#ibc). BEM-события обычно обрабатывает
  экземпляр блока, отслеживающий состояние других блоков, на которых
  генерируются события.
  
Планируя архитектуру интерфейса, следует учитывать, что DOM-события
следует использовать только во *внутренних* процедурах блока. Для
передачи информации между блоками предназначены BEM-события.


-------------------------------------------------------------------------------

**NB** Работа с DOM-событиями полностью реализована средствами
  фреймворка jQuery.

-------------------------------------------------------------------------------


<a name="delegated-events"></a>

## Делегирование событий ##

Обработка BEM- и DOM-событий может быть **делегирована** контейнеру
(всему документу или конкретному DOM-узлу). В этом случае контейнер
служит точкой обработки событий, возникающих на любом из
дочерних узлов контейнера, даже если в момент подписки на события
некоторые из дочерних узлов еще не существовали.

Например, блок меню может содержать вложенные блоки (или элементы — в
зависимости от конкретной реализации блока) — пункты меню. Обработку
кликов на пунктах меню имеет смысл делегировать самому блоку меню. Это
дает возможность более гибко изменять состав меню: добавлять и удалять
пункты, не выполняя при этом подписку на события добавленных пунктов
меню и отмену подписки на события удаленных.

* [**Делегирование DOM-событий**](#dom-events-delegated) следует использовать для обработки
  DOM-событий на *элементах блока*. Поскольку в
  *i-bem.js* элементам не соответствуют отдельные JS-объекты,
  содержащий их экземпляр блока — единственная (и естественная) точка обработки
  событий на элементах.

	Контейнером, получающим DOM-события элементов, служит **DOM-узел экземпляра
    блока**. 
	
* [**Делегирование BEM-событий**](#bem-events-delegated) следует использовать для обработки
  событий на *экземплярах блоков*, содержащихся внутри указанного
  DOM-узла.

	Контейнером, получающим BEM-события других блоков, может служить
	**произвольный DOM-узел**. По умолчанию в качестве контейнера выступает
	весь документ. Часто блок обрабатывает BEM-события вложенных блоков,
	тогда в качестве контейнера используется DOM-узел блока-обработчика
	[`this.domElem`]().




Полный список хелперов для подписки на делегированные события
приведен [в справочном разделе](#live-helpers).


## DOM-события ##

Для добавления и удаления подписки на DOM-события на узлах, связанных с блоком
или элементом, используются методы экземпляра блока [`bindTo([elem],
event, handler)`](#i-bem__dom.bindTo) и [`unbindFrom([elem], event,
handler)`](#i-bem__dom.unbindFrom).

**Пример**: В момент [инициализации экземпляра блока](#init)
`my-block` выполняется подписка на событие `click`, при наступлении
которого блок выставляет себе [модификатор](#modifier) `size` в
значение `big`.

```JavaScript
DOM.decl('my-block', {
	onSetMod : { 
		'js' : { 'inited': {
			function() {
		   		this.bindTo('click', function(e) {
					var domElem = e.currentTarget // DOM-элемент, на котором возникло событие
	   				this.setMod('size', 'big');
   				});
			}
		}
	}
}},
{});
```

-------------------------------------------------------------------------------

**NB** Функция-обработчик выполняется в контексте того экземпляра
  блока, в котором возникло событие.

-------------------------------------------------------------------------------


<a name="dom-events-delegated"></a>

### Делегирование DOM-событий ###

Делегирование обработки DOM-событий на элементах выполняется в
разделе статических методов декларации блока в свойстве `live`. Для
добавления и удаления подписки на DOM-события элементов служат функции
`liveBindTo([elem], event, handler)` и `liveUnbindFrom([elem], event,
[handler])`.

-------------------------------------------------------------------------------

**NB** Подписка на делегированные DOM-события происходит для **всех
  экземпляров** данного блока.

-------------------------------------------------------------------------------


**Пример**: Все экземпляры блока `menu` подписываются на
  делегированное DOM-событие `click` своих элементов `item`. Метод
  `_onItemClick` экземпляра блока `menu` будет выполняться при клике
  на любой пункт (элемент `item`) в этом меню, вне зависимости от того,
  существовал ли этот пункт в момент инициализации экземпляра блока.

```JavaScript
DOM.decl('menu', {
    _onItemClick : function(e) {
        var clickedItem = e.currentTarget // элемент 'item' блока 'menu', на котором произошло DOM-событие 'click'
    }
}, {
    live : function() {
        this.liveBindTo('item', 'click', function() {
            this._onItemClick();
        });
        return false; // если инициализация блока не может быть отложена
    }
});
```

По умолчанию при наличии в декларации блока свойства `live`
инициализация экземпляров блока будет *отложена* до возникновения
первого делегированного события, на которое подписан блок
([ленивая инициализация](#init-live)). Если инициализация блока не
может быть отложена (требуется
[автоматическая инициализация](#init-auto)), следует вернуть `false` в
результате выполнения функции в значении свойства `live`.


### Объект DOM-события ###

В качестве параметра функции-обработчику передается jQuery-объект,
описывающий DOM-событие — [`{jQuery.Event}`](http://api.jquery.com/category/events/event-object/).

Если DOM-событие было сгенерировано вручную, все параметры, переданные
функции `trigger` при создании события, будут переданы
функции-обработчику в том же порядке после объекта события.



<a name="bem-events"></a>

## BEM-события ##

В отличие от DOM-событий, BEM-события генерируются не на
DOM-элементах, а на **экземплярах блоков**. Элементы блоков не могут
генерировать BEM-события.

Чтобы сгенерировать BEM-событие, используется метод экземпляра блока
[`emit(event)`](#i-bem.emit).

**Пример**: Когда пользователь кликает по DOM-элементу кнопки `submit`
(происходит DOM-событие `click`), выполняется метод `_onClick()`
экземпляра блока `submit`, в котором генерируется **BEM-событие**
`click`:

```JavaScript
DOM.decl('submit',
	{
		onSetMod: { 'js': { 'inited': function() {
			this.bindTo('click', this._onClick(e)) // подписка на DOM-событие "click"
			}
		}},
		_onClick: function() {
			this.emit('click') // создание BEM-события "click"
		}
	}, {}
);
```

Для добавления и удаления подписки на BEM-события экземпляров блоков
используются методы экземпляра блока [`on(event, [data], handler, [handlerCtx])`](#i-bem.on) и
[`un(event, [handler], [handlerCtx])`](#-bem.un).


**Пример**: В момент инициализации HTML-формы (экземпляра блока `form`)
выполняется поиск вложенной в форму кнопки `submit` и подписка на
BEM-событие `click` этой кнопки. В результате при нажатии на кнопку
(экземпляр блока `submit`) будет выполнен метод `_onSubmit` формы
(экземпляр блока `form`).

```JavaScript
DOM.decl('form',
	{
		onSetMod: {
			js: {
				'inited': function() {
					this.findBlockInside('submit').on('click', function() { 
						this._onSubmit();
					});
				}
			}
		}
	}, {}
);	
```

<a name="bem-events-delegated"></a>

### Делегирование BEM-событий ###

Делегирование BEM-событий означает, что блок подписывается на
определенное BEM-событие **всех экземпляров** блока с заданным именем
**в пределах заданного контекста**. Добавление и удаление подписки на
делегированные BEM-события выполняется с помощью статических методов
*класса блока* `on([ctx], event, [data], handler, [handlerCtx])` и
`un([ctx], event, [handler], [handlerCtx])`.

Параметры:

* `{jQuery} [ctx]` — DOM-узел, в пределах которого отслеживаются
BEM-события (контейнер). Если не указан, в качестве контейнера
используется весь документ.
* `{String} event` — Имя BEM-события.
* `{Object} [data]` — Произвольные данные, передаваемые
  функции-обработчику.
* `{Function} handler` — Функция-обработчик события.
* `{Object} [handlerCtx]` — Контекст функции-обработчика
  события. Обычно в качестве контекста должен выступать тот экземпляр
  блока, который подписывается на BEM-событие, а не тот, в котором BEM-событие
  произошло.


**Пример**: При инициализации экземпляров блока `menu` выполняется
  подписка на BEM-событие `click` всех ссылок (экземпляров блока
  `link`) в пределах DOM-узла, к которому привязано меню
  (`this.domElem`).  В качестве контекста функции-обработчика
  передается экземпляр блока, в котором событие будет обрабатываться
  (`this`).

```JavaScript
DOM.decl('menu', {
    onSetMod : {
        'js' : {
            'inited' : function() {
                DOM.blocks['link'].on(this.domElem, 'click', this._onLinkClick, this);
            }
        }
    },
    _onLinkClick : function(e) {
        var clickedLink = e.target // экземпляр блока 'link', на котором произошло  BEM-событие 'click'
    }
});
```

Полное описание API для работы с BEM-событиями содержится в [справочном
разделе](#i-bem.events).


<a name="api"></a>

## Объект BEM-события ##

В качестве параметра функции-обработчику передается объект,
описывающий BEM-событие. Объекта BEM-события `events.Event` определен
в [ymaps][]-модуле
[`events`](https://github.com/bem/bem-core/blob/v1/common.blocks/events/events.vanilla.js)
библиотеки bem-core. Содержит поля:

* `target` — Экземпляр блока, в котором произошло BEM-событие.
* `data` — Произвольные дополнительные данные. Передается в качестве
  параметра `data` в момент подписки на BEM-событие или при создании
  BEM-события блоком.
* `result` — Последнее значение, возвращенное обработчиком данного
  события. Аналогично [jQuery.Event.result](http://api.jquery.com/event.result/).
* `type` — Тип события. Аналогично
[jQuery.Event.type](http://api.jquery.com/event.type/).

<a name="ibc"></a>

# Состояния блока #

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор **состояний** блока.  Тогда
поведение блока определяется **триггерами** — callback-функциями, которые
выполняются при переходе блока из одного состояния в другое.

Такой подход позволяет писать код блока в декларативном стиле как
набор утверждений вида:

* Описание состояния — действия, выполняемые при переходе в данное состояние.

<a name="modifiers"></a>

## Модификаторы ##

Согласно БЭМ-методологии, состояние блока и его элементов описывается
**модификаторами**.

* Модификатор — это **имя** и **значение**. Например, `size`: `m`.

* **Простой модификатор**. Частный случай, когда модификатор либо
  присутствует у блока, либо отсутствует. Например, `disabled`. В
  *i-bem.js* представлены как модификаторы с булевым
  значением. Например: `disabled`: `true`. При выставлении
  модификатора с неуказанным значением *i-bem.js* автоматически
  присваивает ему значение `true`.

* Каждому блоку можно назначить один или несколько модификаторов.

* Блок может не иметь модификаторов.

В *i-bem.js* модификаторы могут быть назначены (менять значения):

* при инициализации блока;
* в ходе выполнения кода блока (например, в качестве реакции на [DOM-события](#dom-events));
* по запросу из другого блока. Подробнее см. раздел [Взаимодействие блоков](#ibc).

<a name="mods-api"></a>

### Управление модификаторами ###

Экземпляр блока предоставляет методы для установки, проверки значений
и удаления модификаторов данного экземпляра.

Например, экземпляр блока `square` может по клику на DOM-элементе
блока переключаться между значениями `green` и `red` модификатора
`color`, если не выставлен модификатор `disabled`:

	DOM.decl('square', {
		onSquareClick: function(e) {
			if ( !this.hasMod('disabled') ) {
				this.toggleMod('color', 'green', 'red');
				}
		}
		}, {}
	);


Эти же методы используются для управления модификаторами элементов
блока. Для этого в качестве первого (необязательного) параметра
указывается имя элемента.

Например, блок `searchbox` по клику может выставлять своему элементу
`input` простой модификатор `clean` (подразумеваемое значение —
`true`):

	DOM.decl('searchbox', {
		onClick: function() {
			this.setMod(this.elem('input'), 'clean');
		}
		}, {}
	);

Полное описание API для управления модификаторами приведено в
[справочном разделе](#i-bem.mods).

-------------------------------------------------------------------------------

**NB**: Модификаторы нельзя устанавливать, напрямую меняя CSS класс на
соответствующем DOM-узле. Для изменения значений модификаторов следует
использовать [API](#i-bem.mods), предоставляемое *i-bem.js*.

-------------------------------------------------------------------------------


## Триггеры на установку модификаторов ##

Выполнение триггеров на установку модификаторов разбито на две фазы:

1. **До установки модификатора**. Эта фаза зарезервирована для
   возможности **отменить** установку модификатора. Если хотя бы один
   из триггеров, выполняемых в этой фазе, вернет `false`, установки
   модификатора не произойдет.
2. **После установки модификатора**. Триггеры, выполняемые в этой
   фазе, уже не могут отменить установку модификаторов.

Триггеры могут быть привязаны к следующим типам изменений значений модификаторов:

1. установка *любого* модификатора в *любое* значение;
2. установка *конкретного* модификатора `modName` в *любое* значение (в том числе
   установка простого модификатора в значение `true`);
3. установка *конкретного* модификатора `modName` в *конкретное* значение `modVal`;
4. установка модификатора в значение `''` (пустая строка), что
   эквивалентно удалению модификатора или установке простого
   модификатора в значение `false`). 


При установке модификатора `modName` в значение `modVal` триггеры
каждой фазы (если они определены) вызываются в том порядке, в котором они
перечислены в приведенном выше списке событий (от общего к частному).

Таким образом, при определении триггера пользователь указывает:

* фазу выполнения (до или после установки модификатора);
* тип события (имя и устанавливаемое значение модификатора).

### Декларация триггеров ###

Триггеры, выполняемые при установке модификаторов, описываются в
декларации блока. Для этого в хэше методов экземпляра блока
зарезервированы свойства:

* `beforeSetMod` — триггеры, вызываемые до установки
  **модификаторов блока**. 
* `beforeElemSetMod` — триггеры, вызываемые до установки
  **модификаторов элементов**.
* `onSetMod` — триггеры, вызываемые после установки
  **модификаторов блока**.
* `onElemSetMod` — триггеры, вызываемые после установки
  **модификаторов элементов** блока.

		modules.define('i-bem__dom', function(provide, DOM) {

		DOM.decl(/* селектор блока */,
			{ 
				/* методы экземпляра */
				
				beforeSetMod: { /* триггеры до установки модификаторов блока*/}

				beforeElemSetMod: { /* триггеры до установки модификаторов элементов*/}

				onSetMod: { /* триггеры после установки модификаторов блока */ }
				
				onElemSetMod: { /* триггеры после установки модификаторов элементов */ }
			},
			{
				/* статические методы */
			}
		);

		provide(DOM);
		});


Значение свойств `beforeSetMod` и `onSetMod` — хэш, связывающий
изменения модификаторов с триггерами. В качестве параметров триггерам
передаются:

* имя модификатора;
* выставляемое значение модификатора;
* предшествующее (текущее) значение модификатора.

```JavaScript
{
	'mod1': function(modName, modVal, preModVal) { ... }, // установка mod1 в любое значение
	'mod2': {
		'val1': function(modName, modVal, preModVal) { ... }, // триггер на установку mod2 в значение val1
		'val2': function(modName, modVal, preModVal) { ... }, // триггер на установку mod2 в значение val2
		'': function(modName, modVal, preModVal) { ... } // триггер на удаление модификатора mod2
	'mod3': {
		true: function(modName, modVal, preModVal) { ... }, // триггер на установку простого модификатора mod3
		'': function(modName, modVal, preModVal) { ... }, // триггер на удаление простого модификатора mod3
	},
	'*': function(modName, modVal, preModVal) { ... } // триггер на установку любого модификатора в любое значение
}
```

Для триггера на установку любого модификатора блока в любое значение
существует сокращенная форма записи:

	beforeSetMod: function(modName, modVal, preModVal) { ... }
	onSetMod: function(modName, modVal, preModVal) { ... }
	
Для свойств `beforeElemSetMod` и `onElemSetMod` в хэш значений
добавляется дополнительный уровень вложенности, задающий **элемент**,
на установку модификаторов которого устанавливаются триггеры. В
качестве параметров триггеру передаются:

* имя элемента;
* имя модификатора;
* выставляемое значение модификатора;
* предшествующее (текущее) значение модификатора.


```JavaScript
{
	'elem1': {
		'mod1': function(elem, modName, modVal, preModVal) { ... }, // триггер на установку mod1 элемента elem 1 в любое значение 
		'mod2': {
			'val1': function(elem, modName, modVal, preModVal) { ... }, // триггер на установку	mod2 элемента elem1 в значение val1
			'val2': function(elem, modName, modVal, preModVal) { ... } // триггер на установку mod2 элемента elem1 в значение val2
			}
		},

	'elem2': function(elem, modName, modVal, preModVal) { ... } // триггер на установку любого модификатора элемента elem2 в любое значение
}
```

Сокращенная запись для триггера на установку любого модификатора элемента
`elem1` в любое значение:

	beforeElemSetMod: { 'elem1': function(elem, modName, modVal, preModVal) { ...} }
	onElemSetMod: { 'elem1': function(elem, modName, modVal, preModVal) { ...} }

<a name="init"></a>

## Инициализация ##

Инициализация блока — это создание в памяти браузера JS-объекта,
соответствующего экземпляру блока. Инициализация блока выполняется
функцией [`init()`](#i-bem__dom.init) на заданном фрагменте DOM-дерева.

Каждому экземпляру блока можно приписать три состояния:

* экземпляр блока не инициализирован (JS-объект не создан);
* экземпляр блока инициализирован (JS-объект создан в памяти браузера);
* экземпляр блока уничтожен (JS-объект удален из памяти браузера).

В *i-bem.js* эти состояния экземпляра блока описываются с помощью служебного
модификатора `js`.

* До инициализации экземпляр блока не имеет модификатора `js`.

	`<div class="my-block i-bem" onclick="..." >...</div>`
* В момент инициализации экземпляру блока устанавливается модификатор
  `js` в значении `inited`.

	`<div class="my-block i-bem ` __`my-block_js_inited`__ `" onclick="..." >...</div>`

* При уничтожении экземпляра блока модификатор `js` удаляется.

	`<div class="my-block i-bem" onclick="..." >...</div>`

Если на DOM-узле размещено несколько экземпляров других блоков, то
инициализация одного из них (появление модификатора `my-block_js_inited`)
не влияет на инициализацию остальных.

Пример, на узле инициализирован только экземпляр блока `myblock`,
экземпляр блока `lazy-block` не инициализирован:

```HTML
<div class="my-block my-block_js_inited lazy-block i-bem"
	onclick="return { my-block: {}, lazy-block: {} }" >
	...
</div>
```

-------------------------------------------------------------------------------

**NB** Наличие модификатора `js` позволяет писать разные CSS-стили для
  блока в зависимости от того, инициализирован он или нет.

-------------------------------------------------------------------------------


### Конструктор экземпляра блока ###

На изменение значений модификатора `js` можно назначать триггеры так
же, как и для любых других модификаторов блока.

Триггер на установку модификатора `js` в значение `inited` выполняется
при создании блока. Этот триггер можно считать **конструктором
экземпляра блока**:

	onSetMod: {
		'js': {
			'inited': function() { ... } // конструктор экземпляра блока
		}
	}


### Деструктор экземпляра блока ###

Триггер на удаление модификатора `js` (установку в пустое значение
`''`) выполняется перед удалением блока. Такой триггер можно считать
**деструктором экземпляра блока**.

	onSetMod: {
		'js': {
			'': function() { ... } // деструктор экземпляра блока
		}
	}

<a name="init-wave"></a>

### Волны инициализации ###

Инициализация экземпляров блоков, присутствующих на странице, не
обязательно происходит одновременно. Блоки могут добавляться в ходе
работы (например, за счет динамической генерации HTML на основе
данных, пришедших с сервера) или инициализироваться только по запросу.

В момент вызова любой функции, выполняющей инициализацию блоков,
создается новая **волна инициализации**.

Новая волна инициализации создается в следующих случаях:

* [Автоматическая инициализация всех блоков в документе по событию `domReady`](#init-auto);
* [Инициализация блока по событию на DOM-узле](#init-live) (ленивая инициализация);
* [Явный вызов инициализации блоков на указанном фрагменте DOM-дерева](#init-ajax).


<a name="init-auto"></a>

### Автоматическая инициализация ###

Фреймворк *i-bem.js* позволяет автоматически инициализировать все блоки,
имеющие DOM-представление (привязанные к DOM-элементам на странице) в
момент наступления DOM-события `domReady`. Для этого необходимо
задекларировать на странице блок `i-bem` с модификатором `init` в
значении `auto`. Пример файла `.deps.js`:

    ({
        mustDeps: [
            {
                block: 'i-bem',
                elem: 'dom',
                mods: { 'init': 'auto' }
            }
        ]
    })

При автоматической инициализации в памяти браузера будут созданы
JS-объекты для всех DOM-узлов, в атрибуте `class` которых указан класс
`i-bem`. Инициализация выполняется функцией [init](#i-bem__dom.init).

<a name="init-live"></a>

### Инициализация по событию (ленивая инициализация) ###

Автоматическая инициализация всех блоков в момент загрузки страницы
может быть нежелательной, так как при большом количестве экземпляров
блоков на странице увеличивается время загрузки и объем затраченной
памяти браузера.

В этом случае имеет смысл инициализировать JS-объекты только в тот
момент, когда их функциональность потребуется пользователю, например,
по клику на блоке. Такая инициализация называется **ленивой** или
**live-инициализацией**.

Для описания условий ленивой инициализации зарезервировано свойство
`live` в разделе статических методов декларации блока. Свойство `live`
может принимать два типа значений:

* `Boolean`.<br/> Если `live` установлено в значение `true`, экземпляры
  блоков данного класса будут инициализированы только при попытке
  получить соответствующий экземпляр. Подробнее
  см. раздел [Взаимодействие блоков](#ibc).

```JavaScript
modules.define('i-bem__dom', function(provide, DOM) {
	DOM.decl('my-block',
		{
		onSetMod: { 'js': {
			'inited': function() { ... } // этот код будет выполняться
			// при первом обращении к экземпляру блока
				}
			}
		}, 
		{ live: true } // статические методы и свойства
	);
	provide(DOM);
});
```

* `Function`.<br/> Функция, указанная в качестве значения `live`:

	* Выполняется один раз — при попытке инициализации **первого
	экземпляра** блока заданного класса.
	* Если функция возвращает значение `false`, экземпляры блоков
      будут инициализироваться [автоматически](#init-auto).

С помощью этой функции можно организовать инициализацию экземпляров
блока по наступлению DOM-событий на DOM-узле блока и вложенных элементах
или BEM-событий на вложенных блоках. Для этого в коде
функции следует выполнить подписку на
[делегированные события](#delegated-events).

```JavaScript
modules.define('i-bem__dom', function(provide, DOM) {
	DOM.decl('my-block',
		{
		onSetMod: { 'js': {
			'inited': function() { ... } // выполняется при первом DOM-событии 'click'
				}
			},
			_onClick: function() { ... } // выполняется при каждом DOM-событии 'click'
		}, 
		{ live: function() {
			this.liveBindTo('click', function() {
				this._onClick() // в момент клика будет создан экземпляр блока и вызван его метод _onClick
								});
			}
	);
	provide(DOM);
});
```

Если необходимо воспользоваться делегированными событиями в блоке, но
инициализацию блока нельзя отложить (экземпляры блока должны быть
инициализированы немедленно после загрузки страницы), следует вернуть
значение `false`:


```JavaScript
modules.define('i-bem__dom', function(provide, DOM) {
	DOM.decl('my-block',
		{
		onSetMod: { 'js': {
			'inited': function() { ... } // будет выполнена по
				// наступлении domReady
				}
			},
		_onClick: function() { ... } // будет выполняться каждый
				// раз при наступлении DOM-события 'click'
		}, 
		{ live: function() {
			this.liveBindTo('click', function() { this._onClick() });
			return false; // блоки будут инициализированы автоматически
			}
	);
	provide(DOM);
});
```

Полный список хелперов для подписки на делегированные события
приведен [в справочном разделе](#live-helpers).

-------------------------------------------------------------------------------

**NB** Свойство `live` задает ленивую инициализацию для *всех
  экземпляров* соответствующего блока, т.к. технически относится к
  статическим методам класса блока. Поэтому даже если свойство `live`
  задекларировано для блока с определенным значением модификатора, оно
  будет применено ко всем таким блокам вне зависимости от модификаторов.

-------------------------------------------------------------------------------

<a name="init-ajax"></a>

### Инициализация блоков на фрагменте DOM-дерева ###

Процедура инициализации или уничтожения JS-объектов может быть вызвана
явно для указанного фрагмента DOM-дерева. Часто такая необходимость
возникает при разработке AJAX-интерфейсов, когда нужно динамически
встроить в страницу новые экземпляры блоков либо обновить существующие.


В *i-bem.js* предусмотрены функции следующие для динамической
инициализации блоков:

* Инициализация/уничтожение блоков на указанном фрагменте DOM-дерева
  (`init`, `destruct`);
* Добавление/замена фрагмента DOM-дерева с одновременной
  инициализацией блоков на обновленном фрагменте (`update`, `replace`,
  `append`, `prepend`, `before`, `after`).

**Пример**: В блоке `table` при вызове метода `onRowClick` выполняется
  создание нового фрагмента DOM-дерева (например, на основании
  подгруженных с сервера данных) и подклейка этого фрагмента в
  существующее DOM-дерево с помощью метода `append`. В момент
  подклейки выполняется инициализация всех экземпляров блоков на новом
  фрагменте DOM-дерева.

```JavaScript
DOM.decl('table', {
	onRowClick: function() {
		var ctx, node = ...
		...
		DOM.append(ctx, node)
		...
		},
	{}
);
```


<a name="bem-create"></a>

### Инициализация блоков без DOM-представления ###

Чтобы создать JS-объект для блока, не имеющего DOM-представления (не
привязанного к DOM-элементу), необходимо вызвать метод [`create`](#i-bem.create),
который вернет **FIXME** экземпляр(?) блока:

**FIXME** проверить пример
Например, при вызове метода `get` служебного блока `i-location` создается
экземпляр блока либо возвращается ссылка на уже созданный экземпляр:

**FIXME** — пример обычного блока, который нужно заново
  инстанцировать. пример про инициализацию. 

```JavaScript
modules.define('i-bem', function(provide, BEM) {
	var _instance;
	BEM.decl('i-location',
		{ 
			get: function() {
				return _instance || (_instance = BEM.create('i-location'));
			}
		}, {}
	);
	provide(BEM);
});
```

-------------------------------------------------------------------------------

**NB** Если блок без DOM-представления реализован в виде простого
  [ymaps-модуля][ymaps], то он используется как ymaps-модуль:

```JavaScript
modules.define('router', function(provide) {
	provide({
		route : function() { ... }
	});
});
```

**FIXME** сделать домовский блок my-block, у которого в каком-нибудь
  методе используется этот route.

-------------------------------------------------------------------------------

# Взаимодействие блоков #

БЭМ-методология предполагает, что блоки должны разрабатываться таким
образом, чтобы по возможности исключить зависимость состояний одних
блоков от других. Однако на практике идеал полной независимости блоков
недостижим.

Взаимодействие блоков может быть реализовано двумя способами:

* С помощью подписки на [БЭМ-события](#bem-events) других экземпляров
  блоков или подписки на [делегированные BEM-события](#).
* С помощью непосредственного вызова методов других экземпляров
  блоков или статических методов класса другого блока.


Для реализации взаимодействия блоков *i-bem.js* предоставляет API для
доступа к JS-объектам экземпляров блоков и к JS-объектам классов блоков.

## Поиск экземпляров блоков в DOM-дереве ##

Обращение к другому блоку в *i-bem.js* выполняется из текущего блока,
размещенного на определенном узле DOM-дерева. Поиск других блоков в
DOM-дереве может вестись по трем направлениям (осям) относительно
DOM-узла текущего блока:

* «Внутри блока» — на DOM-узлах, вложенных в DOM-узел текущего блока.
* «Снаружи блока» — на DOM-узлах, потомком которых является DOM-узел
  текущего блока. Необходимость в таком поиске может свидетельствовать
  о неудачной архитектуре интерфейса.
* «На себе» — на том же DOM-узле, на котором размещен текущий
  блок. Это актуально в случае [размещения нескольких JS-блоков на
  одном DOM-узле](#mixes) (микс). 

**FIXME** переделать пример пример bem-components/v2 attach

В примере ниже показано, как блок-контейнер `b-pseudo-link` использует
поиск вложенного блока `b-link`, чтобы подписаться на его BEM-событие
`click` и изменять при его наступлении текст ссылки:

**FIXME** 
Подписка на события класса — основной способ
Подписка на события экземпляра

```JavaScript
myMethod.thisFindBlockInside('my-block').myBlockMethod

BEM.blocks['on'].

DOM.decl('b-pseudo-link', {
	onSetMod: {	'js': { 'inited': function() {
	
		var link = this.findBlockInside('b-link');

	    BEM.blocks['b-link']
			.liveCtxBind(link.domElem, 'click', function(){
				link.elem('inner').text('Кликнутая ссылка');
			}, this);
		}}}
	}, {}
);
```

Полный список методов для поиска блоков блоков приведен
[в справочном разделе](#i-bem__dom.findblocks).


-------------------------------------------------------------------------------

**NB** Не используйте jQuery-селекторы для поиска блоков и элементов.
*i-bem.js* предоставляет [высокоуровневое API](#) для доступа к DOM-узлам
блоков и элементов. Обращение к DOM-дереву в обход этого API менее
устойчивым к изменениям БЭМ-библиотек и может привести к возникновению
сложно обнаруживаемых ошибок.

-------------------------------------------------------------------------------

## Доступ к экземплярам блоков без DOM-представления ##

**FIXME** — доступ к инстансам блоков без дом-представления нужно
  самому позаботиться о том, чтобы положить инстансы этого блока в
  какое-то доступное место. 

**FIXME** —

```
init: my-service-api.
	сложить в this._my-service-api инстанс
	поставить модификатор и через чейнинг позвать какой-нибудь метод
```

**FIXME** Описать, что все деклы попадают вот в эту структуру

JS-компоненты, соответствующие всем блокам («классы» блоков), хранятся
в структуре данных `BEM.blocks`. Классы блоков,
[не привязанных к DOM-дереву](#i-blocks), также размещены в этой
структуре данных. При необходимости доступа к таким блокам следует
использовать конструкцию:

	BEM.blocks['name']

где `name` — имя блока.


**FIXME** — пример делегирования бэм-событий, сделать то же самое с меню
первый параметр контекст — это для классов 
```
BEM.blocks['link'].on(this.domElem, 'click', function(e, this) { ... })
e.target — ссылка на инстанс линка, по кот. кликнули
this — это тот наш блок, в котором мы это обрабатываем
e.target.setMod('disabled') — по клику 
```

**FIXME** — закрыть все попапы какие есть: пример на вызов
статического метода класса
```JavaScript
BEM.blocks['popup'].close()
```


<a name="elem-api"></a>

## Поиск элементов ##

**FIXME** — вся функциональность эта должна быть описана раньше
  взаимодействия блоков.
  Элементы — домовские объекты, удобная работа с дом-объектами нужна. 

Экземпляр блока предоставляет два метода для обращения к элементам данного
экземпляра:

* Кеширующий доступ: [`elem(elems, [modName], [modVal])`](#i-bem__dom.elem). Элемент,
  полученный таким образом, нет необходимости сохранять в переменную.

```JavaScript
DOM.decl('b-link',{
	setInnerText: function() {
		this.elem('inner').text('Текст ссылки');
		...
		this.elem('inner').text('Другой текст');
		}
	}, {}
);
```

* Некеширующий доступ: [`findElem(elems, [modName],
  [modVal])`](#i-bem__dom.findElem).

```JavaScript
DOM.decl('b-link',{
	setInnerText: function() {
		var inner = this.findElem('inner');
		inner.text('Текст ссылки');
		...
		inner.text('Другой текст');
		}
	}, {}
);
```

**FIXME** метод сброса кешей. когда модифицируешь внутренности блока:
  когда динамически достроил каких-то элементов в блок или удалил их.

```
this.elem('smth')
DOM.update(this.domElem, '') (сохраняя обертку, удалили все
внутренности)
а вот тут сбросить кеш
```

Полное описание API для работы с элементами содержится в
[справочном разделе](#i-bem__dom.elems).

	
# Справочник #

<a name="i-bem"></a>

## Модуль i-bem ##

Актуальный исходный код модуля:

* <https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/i-bem.vanilla.js>

### Свойства ###

* `{Object} blocks` — Хэш деклараций блоков. Ключом служит имя блока.


<a name="i-bem.decl"></a>

### Декларация блока ###

`{BEM} decl(desc, methods, staticMethods)` — Декларация блока.

Параметры:

<a name="i-bem.decl.desc"></a>

* `{String|Object} desc` — Имя (строка) или описание блока (хэш).

	В описании зарезервированы следующие ключи:

	* `block` (строка) — имя блока, обязательный параметр.

	* `baseBlock` (строка) — Имя родительского блока (класса). Данный
	блок наследует все методы родительского блока.

	* `baseMix` (массив) — Имена дополнительных родительских блоков,
	позволяет реализовать множественное наследование. Данный блок
	наследует методы всех указанных родительских блоков.

	* `modName` (строка) — Имя модификатора блока. Объявленные методы
	будут привязаны только к экземплярам блока с указанными
	значениями модификатора. Если не указан параметр `modVal`,
	селектор применяется к блокам с указанным модификатором
	независимо от его значения.

	* `modVal` (строка/массив/boolean) — Значение или массив значений
	модификатора блока.  Объявленные методы будут привязаны только к
	экземплярам блока с указанными значениями
	модификатора. Предполагает указание параметра `modName`.
	true, false не работает **FIXME** — добавить про булевы (простые) модификаторы


<a name="i-bem.create"></a>

### Создание экземпляра блока ###

`{BEM} create(block, params)` — Создать экземпляр указанного блока.

Параметры:

* `{String|Object} block` — Имя или описание блока. См. параметр
  [`desc`](#i-bem.decl.desc). 
* `{Object} params` — Параметры блока.


<a name="i-bem.mods"></a>

### Управление модификаторами ###

* hasMod 
* getMod
* getMods
* setMod
* toggleMod
* delMod

Если в качестве первого (необязательного) параметра указано имя
элемента, все методы работают с модификаторами элемента. В противном
случае все методы работают с модификаторами блока.

* `{Boolean} this.hasMod([elem], modName, [modVal])` — Проверить
  наличие модификатора `modName` со значением `modVal` (опционально). 

* `{String} this.getMod([elem], modName)` — Получить значение
  модификатора `modName`.

* `{Object} this.getMods([elem], [modNames])` — Получить хэш значений
  модификаторов блока. Необязательный параметр `modNames` позволяет
  указать список модификаторов (через запятую), значения которых нужно
  вернуть.

* `{BEM} this.setMod([elem], modName, modVal)` — Установить модификатор
  `modName` в значение `modVal`. Возвращает JS-объект блока.

* `{BEM} this.toggleMod([elem], modName, modVal1, modVal2,
  [condition])` — Переключить значение модификатора `modName`. Если
  передан параметр `condition`, выставить `modVal1`, если `true` и
  `modVal2` в обратном случае. Если параметр `condition` не передан,
  то выставить `modVal2`, если текущее значение модификатора `modVal1`
  и наоборот.


<a name="i-bem.events"></a>

### BEM-события ###

<a name="i-bem.emit"></a>

* `{BEM} emit(event, [data])` — Сгенерировать BEM-событие.

	Параметры:
	
	* `{String} event` — Имя события.
	* `{Object} [data]` — Данные, передаваемые обработчику
      события. Необязательный параметр. Обработчик получает переданный
      в этом параметре объект как второй (необязательный) параметр
      `data`.

	Возвращаемое значение: `{BEM}` Контекст, в котором произошло событие.


<a name="i-bem.on"></a>

* `on([ctx], event, [data], handler, [handlerCtx])` — Подписка на
  BEM-событие.

	Параметры:
	
	* `{jQuery} [ctx]` — Контекст, на события в пределах которого
      производится подписка. Необязательный параметр.
	* `{String} event` — Имя события.
	* `{Object [data]}` — Дополнительные данные, передаваемые
      обработчику события. Необязательный параметр. Данные доступны в
      обработчике как поле `e.data` (`e` — контекст события,
      передаваемый обработчику в качестве аргумента).
	* `{Function} handler` — Функция-обработчик события.
	* `{Object} handlerCtx` — Контекст
      функции-обработчика. Необязательный параметр. 

<a name="i-bem.un"></a>

* `un([ctx], event, handler, [fnCtx])` — Удаление подписки на
  BEM-событие.

	Параметры:

	* `{jQuery} [ctx]` — **FIXME** элемент(?) на котором слушалось
      событие. Необязательный параметр.
	* `{String} event` — Имя события.
	* `{Function} handler` — Функция-обработчик события.
	* `{Object} fnCtx` — Контекст функции-обработчика. Необязательный
      параметр.


### Параметры блока ###

* `{Object} getDefaultParams()` — Возвращает хэш параметров блока по
  умолчанию.

* `{String} getName()` — Возвращает имя блока.


<a name="i-bem__dom"></a>

## Модуль i-bem__dom ##

Актуальный исходный код модуля:

* <https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/__dom/i-bem__dom.js>

### Свойства ###

<a name="i-bem__dom.scope"></a>

* scope
* doc
* win

### Свойства экземпляров блоков ###

<a name="i-bem__dom.domElem"></a>

* `{jQuery} domElem` — DOM-узел, на котором размещен блок. Если блок
  [привязан к нескольким DOM-узлам](#distrib-block), содержит все узлы.

* `{Object} params` — Параметры блока.



<a name="i-bem__dom.findblocks"></a>

### Поиск блоков ###

* findBlocksInside
* findBlockInside
* findBlocksOutside
* findBlockOutside
* findBlocksOn
* findBlockOn

Для поиска блоков и их элементов в DOM-дереве определены следующие
методы экземпляра блока: 

* `{BEM} findBlockInside([elem], block)` — Первый указанный блок
  (элемент этого блока) внутри текущего блока.

* `{BEM[]} findBlocksInside([elem], block)` — Коллекция указанных
  блоков (элементов этих блоков) внутри текущего блока.

* `{BEM} findBlockOutside([elem], block)` — Первый указанный блок
  (элемент этого блока) снаружи текущего блока.

* `{BEM[]} findBlocksOutside([elem], block)` — Коллекция указанных
  блоков (элементов этих блоков) снаружи текущего блока.

* `{BEM} findBlockOn([elem], block)` — Первый указанный блок
  (элемент этого блока) на DOM-узле текущего блока.

* `{BEM[]} findBlocksOn([elem], block)` — Коллекция указанных
  блоков (элементов этих блоков) на DOM-узле текущего блока.

Параметры методов:

* `{String|jQuery} elem` — Элемент блока. Необязательный параметр.
* `{String|Object} block` — Искомый блок. Может быть указан двумя
  способами:

	* `{String}` — Имя блока.
	* `{Object}` — Хэш, описывающий блок и значение модификатора, при
      наличии которого следует вернуть блок. Зарезервированы поля:

	* `block` — имя блока;
	* `modName` — название модификатора;
	* `modVal` — значение модификатора.


<a name="i-bem__dom.elems"></a>

### Поиск элементов ###

* findElem
* elem
* dropElemCache
* elemParams
* elemify


* `{jQuery} elem(elems, [modName], [modVal])` — Получить
указанные элементы блока. Результат вызова этого метода кешируется,
поэтому нет необходимости сохранять его в переменную для повторного
использования.

	Параметры:

	* `{String} elems` — Список имен элементов, разделенный пробелами.
	* `{String} [modName]` — Имя модификатора, при наличии которого
      следует вернуть элемент. Необязательный параметр.
	* `{String} [modValue]` — Значение модификатора, при котором
      следует вернуть элемент. Необязательный параметр. Подразумевает
      указание `modName`.

	Возвращает jQuery-коллекцию DOM-элементов.

* `{jQuery} findElem([ctx], elems, [])` — Получить указанные элементы блока. Результат
  вызова метода не кешируется.

	Параметры:

	* `{jQuery} [ctx]` — **FIXME** DOM-элемент, в котором производится
      поиск.
	* `{String} elems` — Список имен элементов, разделенный пробелами. 
	* `{String} [modName]` — Имя модификатора, при наличии которого
      следует вернуть элемент. Необязательный параметр.
	* `{String} [modValue]` — Значение модификатора, при котором
      следует вернуть элемент. Необязательный параметр. Подразумевает
      указание `modName`.
	* `{Boolean} strictMode` — **FIXME**. Необязательный
      параметр. Значение по умолчанию — `false`.

* `{BEM} dromElemCache(elems, [modName], [modVal])` — Удалить
  указанные элементы из кеша.

	Параметры:

	* `{String} elems` — Список имен элементов, разделенный пробелами.
	* `{String} [modName]` — Имя модификатора элемента. Необязательный параметр.
	* `{String} [modVal]` — Значение модификатора элемента. Необязательный параметр.

* `{Object} elemParams(elem)` — Получить параметры указанного
  элемента. **FIXME** — что такое параметры элемента?

	Параметры:
	

* `{jQuery} elemify(elem, elemName)` — Преобразовать заданный DOM-узел
  в элемент блока.

	Параметры:

	* `{jQuery} elem` — DOM-узел.
	* `{String} elemName` — Имя элемента.

   

<a name="i-bem__dom.events"></a>

### Подписка на DOM-события ###

* bindTo
* bindToDomElem
* bindToDoc
* bindToWin
* unbindFrom
* unbindFromDomElem
* unbindFromDoc
* unbindFromWin

<a name="i-bem__dom.bindTo"></a>

* `{BEM} bindTo([elem], event, handler)` — Подписаться на событие на
  DOM-узле блока или элемента.
  
	  Параметры:
  
	  * `{jQuery|String} [elem]` — Элемент блока. Необязательный параметр.
	  * `{String} event` — Список имен DOM-событий, разделенных пробелом.
	  * `{Function} handler` — Функция-обработчик события.

<a name="i-bem__dom.bindToDomElem"></a>

* `{BEM} bindToDomElem(domElem, event, handler)` — Подписаться на событие на
  заданном DOM-узле.
  
	  Параметры:
  
	  * `{jQuery} [elem]` — DOM-узел, на событие которого производится
        подписка.
	  * `{String|Object} event` — Имя или объект события.
	  * `{Function} handler` — Функция-обработчик события. Выполняется
        в контексте экземпляра блока, на котором вызван данный метод.

<a name="i-bem__dom.bindToDoc"></a>

* `{BEM} bindToDoc(event, handler)` — Подписаться на событие в документе.
  
	  Параметры:
  
	  * `{String} event` — Имя события.
	  * `{Function} handler` — Функция-обработчик события. Выполняется
        в контексте экземпляра блока, на котором вызван данный метод.

<a name="i-bem__dom.bindToWin"></a>

* `{BEM} bindToWin(event, handler)` — Подписаться на событие в окне.
  
	  Параметры:
  
	  * `{String} event` — Имя события.
	  * `{Function} handler` — Функция-обработчик события. Выполняется
        в контексте экземпляра блока, на котором вызван данный метод.


<a name="i-bem__dom.unbindFrom"></a>

* `unbindFrom([elem], event, [handler])` — Отменить подписку на событие
  на DOM-узле блока или элемента.
  
	  Параметры:
  
	  * `{jQuery|String} [elem]` — Элемент блока. Необязательный параметр.
	  * `{String} event` — Список имен DOM-событий, разделенных пробелом.
	  * `{Function} handler` — Функция-обработчик
        события. Необязательный параметр.

<a name="i-bem__dom.unbindFromDomElem"></a>

* `unbindFromDomElem(domElem, event, [handler])` — Отменить подписку на событие
  заданного DOM-узла.
  
	  Параметры:
  
	  * `{jQuery} domElem` — DOM-узел.
	  * `{String} event` — Список имен DOM-событий, разделенных пробелом.
	  * `{Function} handler` — Функция-обработчик события. Необязательный параметр.

<a name="i-bem__dom.unbindFromDoс"></a>

* `unbindFromDoс(even, [handler])` — Отменить подписку на событие
  заданного DOM-узла.
  
	  Параметры:
  
	  * `{String} event` — Список имен DOM-событий, разделенных пробелом.
	  * `{Function} handler` — Функция-обработчик события. Необязательный параметр.


<a name="i-bem__dom.unbindFromWin"></a>

* `unbindFromWin(event, [handler])` — Отменить подписку на событие
  заданного DOM-узла.
  
	  Параметры:
  
	  * `{String} event` — Список имен DOM-событий, разделенных пробелом.
	  * `{Function} handler` — Функция-обработчик события. Необязательный параметр.

<a name="live-helpers"></a>

### Ленивая инициализация (Подписка на Live-события) ###

В *i-bem.js* определены хелперы для вызова callback-функций в момент
инициализации по событию:

* `liveInitOnEvent('событие', callback)` — инициализация по событию на блоке или его
  элементе.<br/>
  Callback-функция будет вызвана один раз при инициализации блока.
* `liveBindTo('событие', callback)` — подписка на событие.<br/>
* liveUnbindFrom
* liveInitOnBlockEvent
* liveInitOnBlockInsideEvent


### Размещение блоков на DOM-дереве ###

* init
* destruct
* update
* replace
* append
* prepend
* before
* after

<a name="i-bem__dom.init"></a>

`{jQuery} init([ctx=scope])` — Инициализирует JS-объекты экземпляров блоков на заданном фрагменте DOM-дерева.

Параметры: 

* `{jQuery} ctx` — Корневой элемент фрагмента DOM-дерева, на
  котором следует инициализировать блоки. Необязательный
  параметр. Значение по умолчанию — [`scope`](#i-bem__dom.scope)

Возвращаемое значение: `{jQuery}` Контекст инициализации. **FIXME**
что это такое?


`destruct(ctx, [excludeSelf=false])` — Удаляет JS-объекты экземпляров блоков на заданном фрагменте
DOM-дерева.

Параметры:

* `{jQuery} ctx` — Корневой элемент DOM-дерева, на котором следует
  удалить блоки.
* `{Boolean} excludeSelf` — **FIXME** Исключить корневой элемент?


`update(ctx, content)` — Заменяет фрагмент DOM-дерева в указанном
контексте, удаляя старые блоки и инициализируя новые.

**FIXME** дописать


### Утилиты ###

**FIXME** Нужно ли документировать этих:

* buildSelector
* nextTick
* initBlock
* processParams
* findDomElem
* getParams
* extractParams
* cleanupDomNode
* removeDomNodeFromBlock
* `{Boolean} containsDomElem` 




[ymaps]: https://github.com/ymaps/modules

[bem-tools]: http://ru.bem.info/tools/bem/
