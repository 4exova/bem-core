<!--# i-bem.js: Руководство пользователя-->

# Общие сведения

## i-bem.js: Клиентский Javascript-фреймворк для БЭМ

i-bem.js — специализированный JavaScript-фреймворк для веб-разработки в рамках [БЭМ-методологии](http://ru.bem.info/method/). 
С помощью i-bem.js можно:

 * разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
 * описывать логику работы блока в декларативном стиле — как набор состояний;
 * легко интегрировать JavaScript-код с CSS в стиле БЭМ и BEMHTML-шаблонами;
 * гибко переопределять поведение библиотечных блоков.

i-bem.js не может:

 * работать с состоянием на сервере (только клиентский JavaScript);
 * заменить высокоуровневые фреймворки общего назначения, подобные jQuery.

## БЭМ-методология и JavaScript

С точки зрения БЭМ-методологии веб-интерфейс строится из независимых **блоков** (внутри которых могут 
быть выделены **элементы**). И блоки, и элементы могут иметь состояния, описываемые **модификаторами**.

Работа веб-интерфейса обеспечивается несколькими **технологиями** (HTML, CSS, JS...), 
и описание блока складывается из реализаций в этих технологиях. Обычно реализация разбита на несколько файлов, например:

 * `block.css` — описывает внешний вид блока;
 * `block.bemhtml` — шаблоны для генерации HTML-представления блока;
 * `block.js` — описывает **поведение** блока.

Фреймворк i-bem.js позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:

 + **Блок** — JS-компонент, описывающий логику работы однотипных элементов интерфейса. Например, все кнопки могут быть реализованы
 с использованием блока `button`. Тогда, в соответствии с БЭМ-методологией, `button.css` определяет внешний вид всех кнопок, 
 а `button.js` — их логику работы.  
 + На каждой странице может размещаться более одного **экземпляра** блока. Каждому экземпляру блока соответствует JS-объект, 
 динамически создаваемый в памяти браузера и хранящий состояние данного экземпляра блока.
 + **Элементы** — Особые поля в структуре данных экземпляра блока.  
 + **Модификаторы** — Особые поля экземпляра блока, хранящие информацию о состоянии блока и его элементов.



## Как использовать i-bem.js

Фреймворк i-bem.js входит в состав библиотеки [bem-core](http://github.com/bem/bem-core/).

Можно использовать i-bem.js как часть полного стека БЭМ-инструментов. Свой проект удобно создавать 
на основе шаблонного репозитория [project-stub](http://github.com/bem/project-stub/), в котором 
подключены все необходимые библиотеки и настроена установка БЭМ-инструментов. 

Если не планируется использование других технологий БЭМ-платформы, можно
подключить библиотеку bem-core в существующий проект любым доступным способом.

Исходный код i-bem.js — JS-реализация блока [i-bem](http://github.com/bem/bem-core/tree/v1/common.blocks/i-bem/).
Существенные компоненты реализации: 

 * Прототип описания блока `i-bem.vanilla.js`
 * Реализация элемента [i-bem__dom](https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/\_\_dom/i-bem\_\_dom.js).
 * Внутренние хелперы `i-bem__internal.vanilla.js`

Зависимости: 

 * jQuery. При использовании bem-core отдельная установка jQuery не требуется.
 * Модульная система [ymaps/modules](https://github.com/ymaps/modules). 
 * ymaps-модули `inherit`, `next-tick`, `vow` из библиотеки bem-core.

## Сборка

Разработка в рамках БЭМ-методологии ведется модульно: каждый блок программируется отдельно, финальный исходный
код веб-страниц формируется из описаний блоков с помощью процедур **сборки**.

В файловой системе блок удобно представлять в виде каталога, а реализацию блока 
в каждой из технологий — в виде отдельного файла:

    desktop.blocks/
        myblock/
            myblock.css
            myblock.js
            myblock.bemhtml
            ...

    desktop.blocks/
        otherblock/
            otherblock.css
            otherblock.js
            otherblock.bemhtml
            ...

Для каждой веб-страницы код использованных на ней блоков должен быть собран в единые файлы: 

    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...

Автоматизацию сборки кода результирующих веб-страниц из отдельных описаний блоков осуществляют
инструменты пакета [bem-tools](http://github.com/bem/bem-tools/). 

*?? Можно ли пользоваться i-bem.js, не используя bem-tools?*

## Почему i-bem.js так называется

В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и 
гибко переопределять поведение библиотеки на разных уровнях переопределения.

Служебным блокам в БЭМ принято давать имена с префиксом `i-`. Таким образом, имя `i-bem.js` 
читается как «реализация блока `i-bem` в технологии `js`».


# Привязка JavaScript к HTML

JavaScript-компоненты в i-bem.js служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — привязать обработку определенных событий к
указанному HTML-фрагменту. 

 * Первичным является DOM-дерево документа, в котором размечены блоки, элементы и модификаторы (в атрибутах `class` HTML-элементов). 
 * Таким образом, в DOM-дереве каждому экземпляру блока соответствует DOM-элемент.
 * Если блок имеет JavaScript-реализацию, к каждому упоминанию блока на странице (DOM-элементу) должен быть привязан JS-объект — экземпляр блока.
 * JS-объект, привязанный к DOM-элементу, обрабатывает происходящие на нем события и хранит состояние данного экземпляра блока.

Преимущества этого подхода к связи HTML и JavaScript-компонент: 

 * естественная деградация интерфейса на клиентах с отключенным JavaScript;
 * _прогрессивный рендеринг_ — возможность начать отрисовку элементов интерфейса до окончания загрузки всех данных страницы (например, изображений).


## Синтаксис привязки блоков

Чтобы привязать блок к HTML-элементу, необходимо: 

 1. **Отметить блок в DOM-дереве**.<br/>
 Включить имя блока в список классов HTML-элемента (атрибут `class`).
 2. **Инициализировать экземпляр блока**.<br/> 
 Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.
 3. **Передать параметры экземпляру блока**.<br/>
 Поместить параметры блока в атрибут `onclick`. Параметры блока представляют собой JS-хэш структуры __имя блока—хэш параметров__. 
 Параметры передаются экземпляру блока в момент инициализации.

Соотношение блоков и DOM-элементов не обязательно должно быть
одно-однозначным. Возможны следующие типы связи: 
 
### Один DOM-элемент — один JS-блок

Самый простой и распространенный способ привязки блоков к HTML.

Пример: HTML-элемент `div`, на котором размещен блок `myblock`, параметры блока — пустой список `{}`.

    <div class="myblock i-bem"
        onclick="return { 
            myblock: {},
        }">
        <span class="myblock__item"></span>
     </div>


### Один DOM-элемент — несколько JS-блоков

Техника размещения нескольких блоков на одном DOM-элементе в БЭМ-методологии называется **микс**. 

Пример: HTML-элемент `div`, на котором размещены блоки `myblock` и `anotherblock`, параметры обоих блоков — пустой список `{}`.

    <div class="myblock anotherblock i-bem"
        onclick="return { 
            myblock: {},
            anotherblock: {}
        }">
        <span class="myblock__item"></span>
     </div>


### Один JS-блок на нескольких DOM-элементах

Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из нескольких компонент, 
сосотяние которых должно быть согласовано. Например, виджет «вкладки», где клик по заголовку 
вкладки (один HTML-элемент), меняет содержимое вкладки (другой HTML-элемент). Другой пример —
маркер, обозначающий точку на карте (первый элемент) и связанное с ним описание точки в списке рядом с картой (второй элемент).

Чтобы привязать блок к нескольким DOM-элементам, нужно в параметрах блока на обоих HTML-элементах
указать одинаковое значение `id`.

Пример: Блок `notebook` привязан к HTML-элементам `div` и `span`, в параметрах блока указан общий `id` — `notebook`.

    <div class="notebook i-bem"
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </div>

    ...
    
    <span class="notebook i-bem" >
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </span>


В результате при инциализации блоков будет создан один JS-объект, содержащий ссылки на оба DOM-узла. 
_!!уточнить, верно ли!!_


### JS-блок не привязан к DOM-элементу

Инфраструктурный код, решающий общие задачи интерфейса: связь с бэкэндом, общие вычисления и т.п. — при работе с i-bem.js 
можно оформлять в виде блока, как и весь прочий JS-код. Чтобы не привязывать такие блоки к DOM-дереву икусственно, 
i-bem.js предоставляет возможность создавать блоки без DOM-представления. 

Блоки без DOM-представления:

 * В HTML-коде страницы не указываются.
 * JS-код блока (декларация) пишется с использованием несколько иного синтаксиса, чем для блоков с DOM-представлением. Подробнее см. FIXME. 

**NB**: В общем случае инфраструктурный код следует оформлять не в виде блока без DOM-представления, а в виде ymaps-модуля. Например: 

    modules.define('router', function(provide) {

    provide({
        route : function() { ... }
    });

    });



## Синтаксис передачи параметров

Параметры блока — произвольный JavaScript-объект, который будет передан блоку в момент инициализации. 
Параметры позволяют модифицировать поведение экземпляра блока, привязанного к данному DOM-узлу.

В значении атрибута `onclick` указываются параметры _всех JS\_блоков, размещенных на данном узле_. 
Параметры передаются с помощью конструкции `return` в виде хэша:

 + ключ — имя блока;
 + значение — хэш параметров данного блока. Если данному экземпляру блока не требуются 
   параметры, указывается пустой хэш `{}`.

Такой формат параметров продиктован следующими соображениями:

 * Указание имени блока в параметрах позволяет избежать необходимости парсить значение атрибута `class`,
   что упрощает и ускоряет инициализацию блоков. Это же решение позволяет размещать несколько блоков на одном 
   DOM-узле без необходимости множить атрибуты элемента.
 * Передача параметров в виде нативного JS-объекта позволяет обходиться для этой цели одним HTML-атрибутом
   и передавать в качестве параметров произвольный JS-код.

*NB: на некоторых уровнях переопределения для передачи блока может использоваться другой HTML-атрибут. Например, в 
библиотеке bem-bl для блоков сенсорных интерфейсов используется атрибут `ondblclick`.*

# Описание блока

JS-реализация блока описывает функциональность определенного класса элементов веб-интерфейса. В конкретных 
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует 
функциональность всего класса и имеет собственное состояние, независимое от остальных.

В терминах парадигмы объектно-ориентированного программирования: 

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в _методах_ класса (= блока). 
Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в i-bem.js принято называть **декларацией**, чтобы подчеркнуть принятый в БЭМ декларативный
стиль программирования. В соответствии с декларативным стилем поведение блока программируется как 
утверждения вида _набор условий — реакция блока_.


## Синтаксис декларации

Чтобы декларировать новый JS-блок, необходимо переопределить ymaps-модуль `i-bem__dom`. 

Блоки, имеющие DOM-представление (привязанные к DOM-элементу) декларируются с помощью 
метода `DOM.decl`, принимающим три параметра: 

1. Селектор блока — строка (имя блока) или хэш (описание блока). Подробнее см. FIXME
2. Методы экземпляра блока — хэш.
3. Статические методы — хэш.

```
modules.define('i-bem__dom', function(provide, DOM) {

DOM.decl(/* селектор блока \*/,
    { 
        /* методы экземпляра \*/
    },
    {
        /* статические методы \*/
    }
);

provide(DOM);
});
``` 

<!---`-->

Блоки, не имеющие DOM-представления, декларируются как переопределение ymaps-модуля `i-bem`. 
Вместо метода `DOM.decl` используется метод `BEM.decl`, принимающий те же параметры: 

    modules.define('i-bem', function(provide, BEM) {

    BEM.decl(/* селектор блока \*/,
        { 
            /* методы экземпляра \*/
        },
        {
            /* статические методы \*/
        }
    );
    
    provide(BEM);
    });


## Селектор блока

Селектор представляет собой описание блока, в котором будут применяться
объявленные в декларации методы.  Селектор обязательно содержит имя блока и 
может содержать условия, ограничивающие сферу действия методов определенным 
состоянием блока или наличием других блоков на том же DOM-узле.

Селектор может быть задан в одной из двух форм:

1. Имя блока — строка. 
   Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).
Пример: декларация методов для блока `button`.

```
DOM.decl('button',
    { 
        /* методы экземпляра \*/
    },
    {
        /* статические методы \*/
    }
)
```<!---`-->

2. Описание блока — хэш.
   В описании зарезервированы следующие ключи:

   * `block` (строка) — имя блока, обязательный параметр.

   * `baseBlock` (строка) — Имя родительского блока (класса). Данный блок наследует все методы родительского блока.

   * `baseMix` (массив) — Имена дополнительных родительских блоков, позволяет реализовать множественное наследование. Данный блок наследует методы всех указанных родительских блоков.

   * `modName` (строка) — Имя модификатора блока. Объявленные методы будут привязаны только к экземплярам блока с указанными значениями модификатора. Предполагает указание параметра `modVal`.

   * `modVal` (строка/массив) — Значение или массив значений модификатора блока.  Объявленные методы будут привязаны только к экземплярам блока с указанными значениями модификатора. Предполагает указание параметра `modName`.

Примеры:

Декларация методов для блока `button` с модификатором `pseudo` в значении `yes` (описывает поведение псевдокнопок):

    DOM.decl({ block: 'button', modName: 'pseudo', modVal: 'yes' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )

Блок `checkbutton` наследует блокам `button` и `checkbox`:

    DOM.decl({ block: 'checkbutton', baseBlock: 'button', baseMix: 'checkbox' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )
 


## Контекст

Ссылка на экземпляр блока (контекст) доступна в коде блока посредством ключевого слова `this`.

Контекст содержит зарезервированные поля: 

 + `this.__self`: Ссылается на статические методы класса, к которому принадлжит экземпляр.

Пример: Вызов статического метода в методе экземпляра блока.

    DOM.decl('myblock', {
        method: function() {
            this.__self.staticMethod();
            this.doMore();
        }, 
        {}
    });


 + `this.__base`: Ссылается на реализацию метода в базовом классе, которому наследует данный.
    Позволяет сделать super call. 

Пример: вызов (и модификация) метода родительского класса (базовой реализации метода в классе `button`).

    DOM.decl({ block: 'mybutton', baseBlock: 'button' }, {
        method: function() {
            this.__base();
            this.doMore();
        }, 
        {}
    });



# Состояния блока

## Инициализация

## Модификаторы

## Деструкция

# События

# Взаимодействие блоков

## Селекторы

`BEM.blocks['name']`

## Элементы

# Кастомизация блоков


# Справочник

## Зарезервированные имена параметров

В i-bem.js зарезервированы следующие имена параметров, которые обрабатываются особым образом при инцииализации
всех блоков.

* **id**
    Параметр `id` позволяет размещать один блок на нескольких DOM-узлах. Для этого на обоих узлах в параметрах 
    данного блока указывается один и тот же `id`:

    
    <div class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></div>
    ...
    <span class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></span>

## Методы блоков DOM.decl


# РАЗНОЕ

## Ленивая инициализация

## Блоки без DOM-представления

