<!--# i-bem.js: Руководство пользователя-->

# Общие сведения #

## i-bem.js: Клиентский Javascript-фреймворк для БЭМ ##

i-bem.js — специализированный JavaScript-фреймворк для веб-разработки в рамках [БЭМ-методологии](http://ru.bem.info/method/). 
С помощью i-bem.js можно:

 * разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;
 * описывать логику работы блока в декларативном стиле — как набор состояний;
 * легко интегрировать JavaScript-код с CSS в стиле БЭМ и BEMHTML-шаблонами;
 * гибко переопределять поведение библиотечных блоков.

i-bem.js не может:

 * работать с состоянием на сервере (только клиентский JavaScript);
 * заменить высокоуровневые фреймворки общего назначения, подобные jQuery.

## БЭМ-методология и JavaScript ##

С точки зрения БЭМ-методологии веб-интерфейс строится из независимых **блоков** (внутри которых могут 
быть выделены **элементы**). И блоки, и элементы могут иметь состояния, описываемые **модификаторами**.

Работа веб-интерфейса обеспечивается несколькими **технологиями** (HTML, CSS, JS...), 
и описание блока складывается из реализаций в этих технологиях. Обычно реализация разбита на несколько файлов, например:

 * `block.css` — описывает внешний вид блока;
 * `block.bemhtml` — шаблоны для генерации HTML-представления блока;
 * `block.js` — описывает **поведение** блока.

Фреймворк i-bem.js позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:

 + **Блок** — JS-компонент, описывающий логику работы однотипных элементов интерфейса. Например, все кнопки могут быть реализованы
 с использованием блока `button`. Тогда, в соответствии с БЭМ-методологией, `button.css` определяет внешний вид всех кнопок, 
 а `button.js` — их логику работы.  
 + На каждой странице может размещаться более одного **экземпляра** блока. Каждому экземпляру блока соответствует JS-объект, 
 динамически создаваемый в памяти браузера и хранящий состояние данного экземпляра блока.
 + **Элементы** — Особые поля в структуре данных экземпляра блока.  
 + **Модификаторы** — Особые поля экземпляра блока, хранящие информацию о состоянии блока и его элементов.



## Как использовать i-bem.js ##

Фреймворк i-bem.js входит в состав библиотеки [bem-core](http://github.com/bem/bem-core/).

Можно использовать i-bem.js как часть полного стека БЭМ-инструментов. Свой проект удобно создавать 
на основе шаблонного репозитория [project-stub](http://github.com/bem/project-stub/), в котором 
подключены все необходимые библиотеки и настроена установка БЭМ-инструментов. 

Если не планируется использование других технологий БЭМ-платформы, можно
подключить библиотеку bem-core в существующий проект любым доступным способом.

Исходный код i-bem.js — JS-реализация блока [i-bem](http://github.com/bem/bem-core/tree/v1/common.blocks/i-bem/).
Существенные компоненты реализации: 

 * Прототип описания блока `i-bem.vanilla.js`
 * Реализация элемента [i-bem__dom](https://github.com/bem/bem-core/blob/v1/common.blocks/i-bem/\_\_dom/i-bem\_\_dom.js).
 * Внутренние хелперы `i-bem__internal.vanilla.js`

Зависимости: 

 * jQuery. При использовании bem-core отдельная установка jQuery не требуется.
 * Модульная система [ymaps/modules](https://github.com/ymaps/modules). 
 * ymaps-модули `inherit`, `next-tick`, `vow` из библиотеки bem-core.

## Сборка ##

Разработка в рамках БЭМ-методологии ведется модульно: каждый блок программируется отдельно, финальный исходный
код веб-страниц формируется из описаний блоков с помощью процедур **сборки**.

В файловой системе блок удобно представлять в виде каталога, а реализацию блока 
в каждой из технологий — в виде отдельного файла:

    desktop.blocks/
        myblock/
            myblock.css
            myblock.js
            myblock.bemhtml
            ...

    desktop.blocks/
        otherblock/
            otherblock.css
            otherblock.js
            otherblock.bemhtml
            ...

Для каждой веб-страницы код использованных на ней блоков должен быть собран в единые файлы: 

    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...

Автоматизацию сборки кода результирующих веб-страниц из отдельных описаний блоков осуществляют
инструменты пакета [bem-tools](http://github.com/bem/bem-tools/). 

*?? Можно ли пользоваться i-bem.js, не используя bem-tools?*

## Почему i-bem.js так называется ##

В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и 
гибко переопределять поведение библиотеки на разных уровнях переопределения.

Служебным блокам в БЭМ принято давать имена с префиксом `i-`. Таким образом, имя `i-bem.js` 
читается как «реализация блока `i-bem` в технологии `js`».


# Привязка блоков к HTML #

JavaScript-компоненты в i-bem.js служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — привязать обработку определенных событий к
указанному HTML-фрагменту. 

 * Первичным является DOM-дерево документа, в котором размечены блоки, элементы и модификаторы (в атрибутах `class` HTML-элементов). 
 * Таким образом, в DOM-дереве каждому экземпляру блока соответствует DOM-элемент.
 * Если блок имеет JavaScript-реализацию, к каждому упоминанию блока на странице (DOM-элементу) должен быть привязан JS-объект — экземпляр блока.
 * JS-объект, привязанный к DOM-элементу, обрабатывает происходящие на нем события и хранит состояние данного экземпляра блока.

Преимущества этого подхода к связи HTML и JavaScript-компонент: 

 * естественная деградация интерфейса на клиентах с отключенным JavaScript;
 * _прогрессивный рендеринг_ — возможность начать отрисовку элементов интерфейса до окончания загрузки всех данных страницы (например, изображений).


## Синтаксис привязки блоков ##

Чтобы привязать блок к HTML-элементу, необходимо: 

 1. **Отметить блок в DOM-дереве**.<br/>
 Включить имя блока в список классов HTML-элемента (атрибут `class`).
 2. **Инициализировать экземпляр блока**.<br/> 
 Включить класс `i-bem` в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.
 3. **Передать параметры экземпляру блока**.<br/>
 Поместить параметры блока в атрибут `onclick`. Параметры блока представляют собой JS-хэш структуры __имя блока—хэш параметров__. 
 Параметры передаются экземпляру блока в момент инициализации.

Соотношение блоков и DOM-элементов не обязательно должно быть
одно-однозначным. Возможны следующие типы связи: 
 
### Один DOM-элемент — один JS-блок ###

Самый простой и распространенный способ привязки блоков к HTML.

Пример: HTML-элемент `div`, на котором размещен блок `myblock`, параметры блока — пустой список `{}`.

    <div class="myblock i-bem"
        onclick="return { 
            myblock: {},
        }">
        <span class="myblock__item"></span>
     </div>


### Один DOM-элемент — несколько JS-блоков ###

Техника размещения нескольких блоков на одном DOM-элементе в БЭМ-методологии называется **микс**. 

Пример: HTML-элемент `div`, на котором размещены блоки `myblock` и `anotherblock`, параметры обоих блоков — пустой список `{}`.

    <div class="myblock anotherblock i-bem"
        onclick="return { 
            myblock: {},
            anotherblock: {}
        }">
        <span class="myblock__item"></span>
     </div>


### Один JS-блок на нескольких DOM-элементах ###

Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из нескольких компонент, 
сосотяние которых должно быть согласовано. Например, виджет «вкладки», где клик по заголовку 
вкладки (один HTML-элемент), меняет содержимое вкладки (другой HTML-элемент). Другой пример —
маркер, обозначающий точку на карте (первый элемент) и связанное с ним описание точки в списке рядом с картой (второй элемент).

Чтобы привязать блок к нескольким DOM-элементам, нужно в параметрах блока на обоих HTML-элементах
указать одинаковое значение `id`.

Пример: Блок `notebook` привязан к HTML-элементам `div` и `span`, в параметрах блока указан общий `id` — `notebook`.

    <div class="notebook i-bem"
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </div>

    ...
    
    <span class="notebook i-bem" >
        onclick="return { 
            myblock: { id: 'notebook' },
        }">
    </span>


В результате при инциализации блоков будет создан один JS-объект, содержащий ссылки на оба DOM-узла. 
_!!уточнить, верно ли!!_


### JS-блок не привязан к DOM-элементу ###

Инфраструктурный код, решающий общие задачи интерфейса: связь с бэкэндом, общие вычисления и т.п. — при работе с i-bem.js 
можно оформлять в виде блока, как и весь прочий JS-код. Чтобы не привязывать такие блоки к DOM-дереву икусственно, 
i-bem.js предоставляет возможность создавать блоки без DOM-представления. 

Блоки без DOM-представления:

 * В HTML-коде страницы не указываются.
 * JS-код блока (декларация) пишется с использованием несколько иного синтаксиса, чем для блоков с DOM-представлением. Подробнее см. FIXME. 

**NB**: В общем случае инфраструктурный код следует оформлять не в виде блока без DOM-представления, а в виде ymaps-модуля. Например: 

    modules.define('router', function(provide) {

    provide({
        route : function() { ... }
    });

    });



## Синтаксис передачи параметров ##

Параметры блока — произвольный JavaScript-объект, который будет передан блоку в момент инициализации. 
Параметры позволяют модифицировать поведение экземпляра блока, привязанного к данному DOM-узлу.

В значении атрибута `onclick` указываются параметры _всех JS\_блоков, размещенных на данном узле_. 
Параметры передаются с помощью конструкции `return` в виде хэша:

 + ключ — имя блока;
 + значение — хэш параметров данного блока. Если данному экземпляру блока не требуются 
   параметры, указывается пустой хэш `{}`.

Такой формат параметров продиктован следующими соображениями:

 * Указание имени блока в параметрах позволяет избежать необходимости парсить значение атрибута `class`,
   что упрощает и ускоряет инициализацию блоков. Это же решение позволяет размещать несколько блоков на одном 
   DOM-узле без необходимости множить атрибуты элемента.
 * Передача параметров в виде нативного JS-объекта позволяет обходиться для этой цели одним HTML-атрибутом
   и передавать в качестве параметров произвольный JS-код.

*NB: на некоторых уровнях переопределения для передачи блока может использоваться другой HTML-атрибут. Например, в 
библиотеке bem-bl для блоков сенсорных интерфейсов используется атрибут `ondblclick`.*

# Декларация блока #

JS-реализация блока описывает функциональность определенного класса элементов веб-интерфейса. В конкретных 
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует 
функциональность всего класса и имеет собственное состояние, независимое от остальных.

В терминах парадигмы объектно-ориентированного программирования: 

 * блок — класс;
 * экземпляр блока — экземпляр класса.

В соответствии с ООП, вся функциональность блока реализуется модульно в _методах_ класса (= блока). 
Методы блока подразделяются на:

 * методы экземпляра блока;
 * статические методы.

Код блока в i-bem.js принято называть **декларацией**, чтобы подчеркнуть принятый в БЭМ декларативный
стиль программирования. В соответствии с декларативным стилем поведение блока программируется как 
утверждения вида _набор условий — реакция блока_.

	
## Синтаксис декларации ##

Чтобы декларировать новый JS-блок, необходимо переопределить ymaps-модуль `i-bem__dom`. 

Блоки, имеющие DOM-представление (привязанные к DOM-элементу) декларируются с помощью 
метода `DOM.decl`, принимающим три параметра: 

1. Селектор блока — строка (имя блока) или хэш (описание блока). Подробнее см. FIXME
2. Методы экземпляра блока — хэш.
3. Статические методы — хэш.

        modules.define('i-bem__dom', function(provide, DOM) {
        
        DOM.decl(/* селектор блока \*/,
            { 
                /* методы экземпляра \*/
            },
            {
                /* статические методы \*/
            }
        );
        
        provide(DOM);
        });

Блоки, не имеющие DOM-представления, декларируются как переопределение ymaps-модуля `i-bem`. 
Вместо метода `DOM.decl` используется метод `BEM.decl`, принимающий те же параметры: 

    modules.define('i-bem', function(provide, BEM) {

    BEM.decl(/* селектор блока \*/,
        { 
            /* методы экземпляра \*/
        },
        {
            /* статические методы \*/
        }
    );
    
    provide(BEM);
    });


<a name="decl_selector"></a>

## Селектор блока ##

Селектор представляет собой описание блока, в котором будут применяться
объявленные в декларации методы.  Селектор обязательно содержит имя блока и 
может содержать условия, ограничивающие сферу действия методов определенной
модификацией блока или наличием других блоков на том же DOM-узле.

Селектор может быть задан в одной из двух форм:

1. Имя блока — строка. 
   Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).
Пример: декларация методов для блока `button`.

        DOM.decl('button',
            { 
                /* методы экземпляра \*/
            },
            {
                /* статические методы \*/
            }
        )

2. Описание блока — хэш.
   В описании зарезервированы следующие ключи:

   * `block` (строка) — имя блока, обязательный параметр.

   * `baseBlock` (строка) — Имя родительского блока (класса). Данный
     блок наследует все методы родительского блока.

   * `baseMix` (массив) — Имена дополнительных родительских блоков,
     позволяет реализовать множественное наследование. Данный блок
     наследует методы всех указанных родительских блоков.

   * `modName` (строка) — Имя модификатора блока. Объявленные методы
     будут привязаны только к экземплярам блока с указанными
     значениями модификатора. Если не указан параметр `modVal`,
     селектор применяется к блокам с указанным модификатором
     независимо от его значения.

   * `modVal` (строка/массив) — Значение или массив значений
     модификатора блока.  Объявленные методы будут привязаны только к
     экземплярам блока с указанными значениями
     модификатора. Предполагает указание параметра `modName`.

Примеры:

Декларация методов для блока `button` с модификатором `pseudo` в значении `yes` (описывает поведение псевдокнопок):

    DOM.decl({ block: 'button', modName: 'pseudo', modVal: 'yes' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )

Блок `checkbutton` наследует блокам `button` и `checkbox`:

    DOM.decl({ block: 'checkbutton', baseBlock: 'button', baseMix: 'checkbox' }, 
        { /* методы экземпляра */ }, 
        { /* статические методы */} 
    )
 


## Контекст ##

В коде блока контекстом всегда является JS-объект экземпляра блока, а
не DOM-элемент, на котором размещен блок. Ссылка на экземпляр блока
(контекст) доступна в коде блока посредством ключевого слова `this`.

**NB**: Для обращения к DOM-элементу блока используется общий метод
  блоков `getElem`. Подробнее см. FIXME.

Контекст содержит зарезервированные поля:

 + `this.__self`: Ссылается на статические методы класса, к которому принадлжит экземпляр.

Пример: Вызов статического метода в методе экземпляра блока.

    DOM.decl('myblock', {
        method: function() {
            this.__self.staticMethod();
            this.doMore();
        }, 
        {}
    });


 + `this.__base`: Ссылается на реализацию метода в базовом классе, которому наследует данный.
    Позволяет выполнить super call. 

Пример: вызов (и модификация) метода родительского класса (базовой реализации метода в классе `button`).

    DOM.decl({ block: 'mybutton', baseBlock: 'button' }, {
        method: function() {
            this.__base();
            this.doMore();
        }, 
        {}
    });

	
# Состояния блока #

Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор **состояний** блока.  Тогда
поведение блока определяется **триггерами** — callback-функциями, которые
выполняются при переходе блока из одного состояния в другое.

Такой подход позволяет писать код блока в декларативном стиле как
набор утверждений вида:

* Описание состояния — действия, выполняемые при переходе в данное состояние.

## Модификаторы ##

Согласно БЭМ-методологии, состояние блока и его элементов описывается
**модификаторами**.

* Модификатор это **имя** и **значение**. Например, `size`: `m`.
* Модификатор может не иметь значения. Например, `disabled`.
* Каждому блоку можно назначить один или несколько модификаторов.
* Блок может не иметь модификаторов.

В i-bem.js модификаторы могут быть назначены (менять значения):

* при инициализации блока;
* в ходе выполнения кода блока (например, в качестве реакции на DOM-события);
* по запросу из другого блока. Подробнее см. События FIXME

-------------------------------------------------------------------------------

**NB**: Модификаторы нельзя устанавливать, напрямую меняя CSS класс на
соответствующем DOM-узле. Для изменения значений модификаторов следует
использовать API, предоставляемое i-bem.js.

-------------------------------------------------------------------------------

## Триггеры ##

Триггеры могут быть привязаны к следующим типам событий:

1. установка *любого* модификатора в *любое* значение;
2. установка модификатора `modName` в *любое* значение (в том числе
   установка модификатора *без значения*);
3. установка модификатора `modName` в значение `modVal`.

При установке модификатора `modName` в значение `modVal` триггеры
(если они определены) вызываются в том порядке, в котором перечислены
события.

При установке пустой строки в качестве значения модификатора этот
модификатор удаляется.


-------------------------------------------------------------------------------

**NB** Если хотя бы один из триггеров вернет `false`, установки
модификатора не произойдет.

-------------------------------------------------------------------------------

Новое значение модификатора присваивается блоку *после выполнения всех
триггеров*. Если необходимо выполнить какие либо операции после
установки модификатора, следует использовать метод
`nextTick`. Подробнее см. FIXME.


### Декларация триггеров ###

Триггеры, выполняемые при установке модификаторов, описываются в
декларации блока. Для этого в хэше методов экземпляра блока
зарезервированы свойства:

* `onSetMod` — триггеры, вызываемые при установке
  *модификаторов блока*.
* `onElemSetMod` — триггеры, вызываемые при установке
  *модификаторов элементов* блока.

		modules.define('i-bem__dom', function(provide, DOM) {

		DOM.decl(/* селектор блока \*/,
			{ 
				/* методы экземпляра \*/
				
				onSetMod: { /* триггеры на установку модификаторов блока */ }
				
				onElemSetMod: { /* триггеры на установку модификаторов элементов */ }
			},
			{
				/* статические методы \*/
			}
		);

		provide(DOM);
		});


Значение свойства `onSetMod` — хэш, связывающий изменения модификаторов с триггерами:

	{
		'mod1': function() { ... }, // триггер на установку mod1 в любое значение
		'mod2': {
			'val1': function() { ... }, // триггер на установку mod2 в значение val1
			'val2': function() { ... } // триггер на установку mod2 в значение val2
		},
		'*': function() { ... } // триггер на установку любого модификатора в любое значение
	}

Для триггера на установку любого модификатора в любое значение
существует сокращенная форма записи:

	onSetMod: function() { ... }

Для свойства `onElemSetMod` в хэш значений добавляется дополнительный
уровень вложенности, задающий **элемент**, на установку модификаторов
которого устанавливаются триггеры:

	
	{
		'elem1': {
			'mod1': function() { ... }, // триггер на установку mod1 элемента elem 1 в любое значение 
			'mod2': {
				'val1': function() { ... }, // триггер на установку	mod2 элемента elem1 в значение val1
				'val2': function() { ... } // триггер на установку mod2 элемента elem1 в значение val2
				}
			},
			
		'elem2': function() { ... } // триггер на установку любого модификатора элемента elem2 в любое значение
	}


### Параметры триггеров ###

Всем callback-функциям, определенным в качестве триггеров на установку
модификаторов, передаются следующие параметры: 

* `{jQuery} [elem]` — Имя элемента. Необязательный параметр, только
  для триггеров на модификаторы элементов.
* `{String} modName` — Имя модификатора.
* `{String} modVal` — Устанавливаемое значение модификатора. FIXME:
  значение, если модификатор удаляется.
* `{String} curModVal` — Текущее значение модификатора. FIXME:
  значение, если модификатора не было.

## Инициализация ##

Инициализация блока — это создание в памяти браузера JS-объекта,
соответствующего экземпляру блока. Инициализация блока выполняется
функцией [`DOM.init()`]() на фрагменте DOM-дерева.

Каждому блоку можно приписать три состояния:

* блок не инициализирован (JS-объект не создан);
* блок инициализирован (JS-объект создан в памяти браузера);
* блок уничтожен (JS-объект удален из памяти браузера).

В i-bem.js эти состояния блока описываются с помощью служебного
модификатора `js`.

* До инициализации блок не имеет модификатора `js`.
* В момент инициализации блоку устанавливается модификатор `js` в
  значении `inited`.
* При уничтожении блока модификатор `js` удаляется.

DOM-представление инициализированного блока:

    <div class="myblock myblock_js_inited i-bem"
		onclick="return { 'myblock' : {} }">
    ...
    </div>

Если на DOM-узле размещено несколько блоков, то инициализация одного
из них (появление модификатора `block_js_inited`) не влияет на
инициализацию остальных.

-------------------------------------------------------------------------------

**NB** Наличие модификатора `js` позволяет писать разные CSS-стили для
  блока в зависимости от того, инициализирован он или нет.

-------------------------------------------------------------------------------


### Конструктор блока ###

На изменение значений модификатора `js` можно назначать триггеры так
же, как и для любых других модификаторов блока.

Триггер на установку модификатора `js` в значение `inited` является
первой функцией, выполняющейся при создании блока. Такой триггер можно
назвать **конструктором экземпляра блока**:

	onSetMod: {
		'js': {
			'inited': function() { ... } // конструктор экземпляра блока
		}
	}


### Деструктор блока ###

Триггер на удаление модификатора `js` (установку в пустое значение `''`) является
последней функцией, выполняемой перед удалением блока. Такой триггер
можно назвать **деструктором экземпляра блока**.

	onSetMod: {
		'js': {
			'': function() { ... } // деструктор экземпляра блока
		}
	}
	

### Автоматическая инициализация всех блоков ###

Фреймворк i-bem.js позволяет автоматически инициализировать все блоки,
имеющиеся на странице в момент наступления события `domReady`. Для
этого необходимо задекларировать на странице блок `i-bem` с
модификатором `init` в значении `auto`. Пример файла `.deps.js`:

    ({
        mustDeps: [
            {
                block: 'i-bem',
                elem: 'dom',
                mods: { 'init': 'auto' }
            }
        ]
    })

При автоматической инициализации в памяти браузера будут созданы
JS-объекты для всех DOM-узлов, в атрибуте `class` которых указан класс
`i-bem`, а также для всех блоков, задекларированных как блоки, [не
имеющие DOM-представления]().


### Инициализация по событию (live-инициализация) ###

Автоматическая инициализация всех блоков в момент загрузки страницы
может быть нежелательной, так как при большом количестве экземпляров
блоков на странице увеличивается время загрузки и объем затраченной
памяти браузера.

В этом случае имеет смысл инициализировать JS-объекты только в тот
момент, когда их функциональность потребуется пользователю, например,
по клику на блоке. Такая инициализация называется **ленивой** или
**live-инициализацией**.

Для описания условий ленивой инициализации зарезервировано свойство
`live` в разделе статических методов декларации блока:

	modules.define('i-bem__dom', function(provide, DOM) {

	DOM.decl(/* селектор блока */,
		{ 
			/* методы экземпляра */
		},
		{
			/* статические методы */
			live: { ... } // условия инициализации по событию
		}
	);

	provide(DOM);
	});
	
Свойство `live` может принимать два типа значений:

* `Boolean`.<br/>
  Если `live` установлено в значение `true`, блок будет
  инициализирован только при обращении к нему из другого
  блока. Подробнее см. раздел [Взаимодействие блоков](#api).
  
* `Function`.<br/>
  Функция, указанная в качестве значения `live`, будет выполнена один
  раз — при попытке инициализации первого экземпляра блока, заданного
  [селектором](#decl_selector) в декларации блока.
  В этой функции следует выполнить подписку на событие, при
  наступлении которого нужно инициализировать блок. 

В i-bem.js определены хелперы для вызова callback-функций в момент
инициализации по событию:

* `liveInitOnEvent('событие', callback)` — инициализация по событию на блоке или его
  элементе.<br/>
  Callback-функция будет вызвана один раз при инициализации блока.
* `liveBindTo('событие', callback)` — подписка на событие.<br/>
  Callback-функция будет вызываться каждый раз при наступлении события
  на экземпляре блока.

Callback-функция принимает один параметр — FIXME.


Пример блока, экземпляры которого будут инициализированы по первому
клику на соответствующем DOM-элементе. При инициализации будет вызван
метод `_onClick` экземпляра блока:

	modules.define('i-bem__dom', function(provide, DOM) {

	DOM.decl(/* селектор блока */,
		{ 
			/* методы экземпляра */
			onClick: function(e) { ... }
		},
		{
			/* статические методы */
			live: function() {
				this.liveBindTo('click', function(e) {
					this._onClick(e);
				});
			} 
		}
	);

	provide(DOM);
	});
	

# События #
	
В i-bem.js поддерживается три(?) вида событий:

* **DOM-события** — JavaScript-события, возникающие на DOM-узлах,
  соответствующих блокам. Это события, отражающие взаимодействие
  пользователя с интерфейсом (клик, наведение мыши, ввод текста и
  т.п.)
* **BEM-события** — собственные события блоков. Позволяют организовать
  API для взаимодействия с блоком.
* **Live-события** — FIXME.

## DOM-события ##

В коде блока 

## BEM-события ##

## Live-события ##

FIXME: что такое делегированные события.

<a name="api"></a>

# Взаимодействие блоков #

Может возникнуть необходимость управлять другим блоком. Для любых
манипуляций с блоком необходимо получить доступ к js-объекту этого
блока и вызывать его методы.

## Блоки ##

`BEM.blocks['name']`

## Элементы ##

NB: Напрямую блок к элементу другого блока не может обратиться, только через блок.

## Модификаторы ##

# Справочник #

## Зарезервированные имена параметров ##

В i-bem.js зарезервированы следующие имена параметров, которые обрабатываются особым образом при инцииализации
всех блоков.

* **id**
    Параметр `id` позволяет размещать один блок на нескольких DOM-узлах. Для этого на обоих узлах в параметрах 
    данного блока указывается один и тот же `id`:

    
    <div class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></div>
    ...
    <span class="myblock i-bem" onclick="return { myblock: { id: 1 }}"></span>

## Общие методы блоков ##


# Примеры #

## Кастомизация блоков ##




